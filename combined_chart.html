<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통합 고급 분석 차트 (Single-Pass 알고리즘)</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            background-color: black; color: white; font-family: sans-serif;
            margin: 0; padding: 0; display: flex; flex-direction: column;
            align-items: center; min-height: 100vh;
        }
        #integrated-controls-panel {
            width: 100%; background-color: #1e1e1e; color: #ccc;
            padding: 4px 10px; display: flex; flex-wrap: wrap;
            justify-content: flex-start; align-items: center;
            box-sizing: border-box; border-bottom: 1px solid #444;
            position: sticky; top: 0; z-index: 1001; gap: 12px;
        }
        .ic-group { display: flex; align-items: center; gap: 6px; padding: 2px 8px; border-right: 1px solid #444; }
        .ic-group:last-child { border-right: none; }
        #integrated-controls-panel span,
        #integrated-controls-panel label {
            font-size: 0.85em; white-space: nowrap; margin: 0;
        }
        #integrated-controls-panel input[type="checkbox"],
        #integrated-controls-panel input[type="number"] {
            vertical-align: middle; margin: 0 2px 0 0; cursor: pointer;
            background-color: #333; color: white; border: 1px solid #555;
            font-size: 0.8em; padding: 2px; border-radius: 3px;
            width: 50px;
        }
        #integrated-controls-panel input[type="datetime-local"] {
            background-color: #333; color: white; border: 1px solid #555;
            font-size: 0.8em; padding: 2px; border-radius: 3px;
        }
        button.control-button {
            background-color: rgba(51, 51, 51, 0.9); color: white;
            border: 1px solid #555; padding: 3px 8px; cursor: pointer;
            border-radius: 4px; font-size: 0.8em;
            transition: background-color: 0.2s; white-space: nowrap;
        }
        button.control-button:hover { background-color: rgba(85, 85, 85, 0.9); }
        button.control-button.active { background-color: rgba(0, 123, 255, 0.8); border-color: #007bff; }
        #chart-context-menu {
            position: absolute; background-color: rgba(51, 51, 51, 0.95); color: white;
            padding: 5px 0; border-radius: 5px; border: 1px solid #666;
            z-index: 1000; display: none; min-width: 150px;
        }
        #chart-context-menu button {
            display: block; width: 100%; padding: 8px 15px; border: none;
            background-color: transparent; color: white; text-align: left;
            cursor: pointer; font-size: 0.9em;
        }
        #chart-context-menu button:hover { background-color: rgba(85, 85, 85, 0.9); }
    </style>
</head>
<body>
    <div id="integrated-controls-panel">
        <div class="ic-group">
            <span id="symbol">Symbol: BTCUSDT</span>
            <span id="timeframe-display">Timeframe: 1m</span>
            <span id="countdown">Countdown: 00:00</span>
        </div>
        <div class="ic-group" id="timeframe-buttons">
            <button class="control-button" data-timeframe="1m">1m</button>
            <button class="control-button" data-timeframe="5m">5m</button>
            <button class="control-button" data-timeframe="15m">15m</button>
            <button class="control-button" data-timeframe="1h">1h</button>
            <button class="control-button" data-timeframe="4h">4h</button>
            <button class="control-button" data-timeframe="1d">1d</button>
        </div>
        <div class="ic-group" id="analysis-tools">
            <button id="set-criterion-btn" class="control-button">기준선 분석 (C)</button>
            <button id="full-analysis-btn" class="control-button">전체 분석</button>
            <button id="auto-label-btn" class="control-button">자동 라벨링 (P/T)</button>
            <button id="find-retracement-btn" class="control-button">되돌림 패턴 (R)</button>
            <button id="clear-shapes-btn" class="control-button">전체 삭제</button>
            <label for="lookaround-input">민감도:</label>
            <input type="number" id="lookaround-input" value="10">
            <label for="tolerance-input">이탈(%):</label>
            <input type="number" id="tolerance-input" value="0.05" step="0.01">
        </div>
        <div class="ic-group" id="drawing-controls">
             <button id="toggle-box-drawing-button" class="control-button">📦 Box</button>
             <button id="measure-tool-btn" class="control-button">📏 자</button>
        </div>
        <div class="ic-group" id="view-controls">
            <label for="x-autorange-toggle-top">X Auto:</label>
            <input type="checkbox" id="x-autorange-toggle-top" style="width:auto;">
            <label for="y-autorange-toggle-top">Y Auto:</label>
            <input type="checkbox" id="y-autorange-toggle-top" checked style="width:auto;">
            <button id="zoom-in" class="control-button">T+</button>
            <button id="zoom-out" class="control-button">T-</button>
            <button id="zoom-price-up" class="control-button">P+</button>
            <button id="zoom-price-down" class="control-button">P-</button>
        </div>
        <div class="ic-group" id="time-travel-controls">
            <button id="calendar-icon-button" class="control-button" title="과거 데이터 조회 (시간 여행)">📅</button>
            <div id="time-travel-picker-area" style="display: none; align-items: center; gap: 5px;">
                <input type="datetime-local" id="datetime-picker">
                <button id="load-past-data-button" class="control-button">로드</button>
            </div>
            <button id="go-live-button" class="control-button" style="display: none;">실시간</button>
        </div>
    </div>

    <div id="main-chart-area" style="display:flex; flex-direction:column; width:95%; max-width:1600px; height:85vh; min-height:350px; margin: 10px auto 15px auto;">
        <div id="chart-container-top" style="flex: 1; min-height: 100px;"></div>
        <div id="chart-container-bottom" style="flex: 1; min-height: 100px;"></div>
    </div>
    
    <div id="chart-context-menu">
        <button id="delete-box">박스 삭제</button>
    </div>

<script>
// ===================================================================================
// 전역 변수 (선언만)
// ===================================================================================
let chartContainerTop, chartContainerBottom, xAutoRangeToggle, yAutoRangeToggle,
    zoomInButton, zoomOutButton, zoomPriceUpButton, zoomPriceDownButton,
    contextMenu, timeframeButtonsContainer, calendarIconButton, timeTravelPickerArea,
    datetimePicker, loadPastDataButton, goLiveButton, toggleBoxDrawingButton, deleteBoxButton;

let isBoxDrawingEnabled = false, drawnBoxes = [], currentBoxFirstPoint = null, contextMenuTargetInfo = null,
    isFullAnalysisDone = false, selectionBox = null, selectedSeries = [],
    allKlinesData = {'1m':[],'5m':[],'15m':[],'1h':[],'4h':[],'1d':[]},
    isXAutoRangeEnabled = false, isYAutoRangeEnabled = true, currentSymbol = "BTCUSDT",
    activeAnalysisTimeframe = "15m", allWebSockets = {}, nextCandleTime = {},
    candleIntervalMillis = {}, countdownInterval = null, chartInitialized = false,
    fetchingMoreData = false, isInTimeTravelMode = false, isRelayouting = false;

let isMeasureModeEnabled = false, measureStartPoint = null; 

const BOX_SHAPE_NAME_PREFIX = 'userDrawnBox_', MAX_DISPLAY_CANDLES = 1000,
    Y_AXIS_ZOOM_FACTOR = 0.05, X_AXIS_ZOOM_FACTOR = 0.10, PAN_FRACTION = 0.10,
    CANDLES_TO_FETCH_ON_PAN = 200, INITIAL_CANDLES_TO_FETCH = 1000,
    MAX_HISTORY = 3000, MAX_HISTORY_1M = 15000,
    CROSSHAIR_LINE_STYLE = { color: 'grey', width: 0.5, dash: 'dash' },
    ALL_TIMEFRAMES = ['1m', '5m', '15m', '1h', '4h', '1d'];

// ===================================================================================
// 함수 정의
// ===================================================================================
function createDate(timestamp) { return new Date(timestamp); }
function getHiddenCrosshairShapes() { return [{ name: "crosshair_v", visible: false }, { name: "crosshair_h", visible: false }]; }

function calculateCandleIntervalMillis(tf) {
    if (tf.endsWith('m')) { return parseInt(tf.slice(0, -1)) * 60 * 1000; }
    else if (tf.endsWith('h')) { return parseInt(tf.slice(0, -1)) * 60 * 60 * 1000; }
    else if (tf.endsWith('d')) { return parseInt(tf.slice(0, -1)) * 24 * 60 * 60 * 1000; }
    return 60000;
}

ALL_TIMEFRAMES.forEach(tf => {
    candleIntervalMillis[tf] = calculateCandleIntervalMillis(tf);
});

function updateTopBar() {
    const timeframeDisplaySpan = document.getElementById('timeframe-display');
    const symbolSpan = document.getElementById('symbol');
    const countdownSpan = document.getElementById('countdown');
    if (timeframeDisplaySpan) timeframeDisplaySpan.textContent = `Timeframe: ${activeAnalysisTimeframe.toUpperCase()}`;
    if (symbolSpan) symbolSpan.textContent = `Symbol: ${currentSymbol}`;
    if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
    
    if (isInTimeTravelMode) {
        if (countdownSpan) countdownSpan.textContent = "과거 데이터 조회 중";
        return;
    }

    const now = Date.now();
    const interval = candleIntervalMillis[activeAnalysisTimeframe];
    if (!interval) { return; }

    const currentIntervalStart = Math.floor(now / interval) * interval;
    nextCandleTime[activeAnalysisTimeframe] = currentIntervalStart + interval;
    
    const updateCountdown = () => {
        const timeLeft = nextCandleTime[activeAnalysisTimeframe] - Date.now();
        if (timeLeft <= 0) {
            if (countdownSpan) countdownSpan.textContent = `Countdown: 00:00`;
            setTimeout(updateTopBar, 1000);
            return;
        }
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        if (countdownSpan) countdownSpan.textContent = `Countdown: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    };
    
    updateCountdown();
    countdownInterval = setInterval(updateCountdown, 1000);
}

function initializePlotly() {
    const trace15m = {x:allKlinesData['15m'].map(d=>createDate(d[0])),open:allKlinesData['15m'].map(d=>Number(d[1])),high:allKlinesData['15m'].map(d=>Number(d[2])),low:allKlinesData['15m'].map(d=>Number(d[3])),close:allKlinesData['15m'].map(d=>Number(d[4])),type:'candlestick',xaxis:'x',yaxis:'y',increasing:{line:{color:'darkorange'}},decreasing:{line:{color:'royalblue'}},name:'15m'};
    const layout15m = {dragmode:'pan',xaxis:{title:'시간 (KST)',type:'date',rangeslider:{visible:false},fixedrange:false,tickformat:'%y/%m/%d %H:%M',color:'#A9A9A9',gridcolor:'#404040'},yaxis:{autorange:isYAutoRangeEnabled,fixedrange:false,color:'#A9A9A9',gridcolor:'#404040'},plot_bgcolor:'#1a1a1a',paper_bgcolor:'black',font:{color:'white'},margin:{t:20,b:20,l:60,r:60},hovermode:false,showlegend:false,shapes:[...getHiddenCrosshairShapes()],annotations:[]};
    const config = {responsive:true,displayModeBar:false,scrollZoom:false};
    const trace1m = {x:allKlinesData['1m'].map(d=>createDate(d[0])),open:allKlinesData['1m'].map(d=>Number(d[1])),high:allKlinesData['1m'].map(d=>Number(d[2])),low:allKlinesData['1m'].map(d=>Number(d[3])),close:allKlinesData['1m'].map(d=>Number(d[4])),type:'candlestick',xaxis:'x',yaxis:'y',increasing:{line:{color:'darkorange'}},decreasing:{line:{color:'royalblue'}},name:'1m'};
    const layout1m = {dragmode:'pan',xaxis:{title:'시간 (KST)',type:'date',rangeslider:{visible:false},fixedrange:false,tickformat:'%y/%m/%d %H:%M',color:'#A9A9A9',gridcolor:'#404040'},yaxis:{autorange:isYAutoRangeEnabled,fixedrange:false,color:'#A9A9A9',gridcolor:'#404040'},plot_bgcolor:'#1a1a1a',paper_bgcolor:'black',font:{color:'white'},margin:{t:20,b:40,l:60,r:60},hovermode:false,showlegend:false,shapes:[...getHiddenCrosshairShapes()],annotations:[]};

    return Promise.all([
        Plotly.newPlot(chartContainerTop, [trace15m], layout15m, config),
        Plotly.newPlot(chartContainerBottom, [trace1m], layout1m, config)
    ]).then(()=>{
        chartInitialized=true;
        setupChartEventListeners();
        setTimeout(()=>{
            if(chartContainerTop._fullLayout){
                const synchronizedRange = chartContainerTop._fullLayout.xaxis.range;
                Plotly.relayout(chartContainerBottom,{'xaxis.range':synchronizedRange});
            }
        },100);
    }).catch(err=>{console.error("Error initializing Plotly:",err);chartInitialized=false;throw err;});
}

function updatePlotlyChart(data, targetContainer) {
    if (!chartInitialized || !data || !targetContainer) return;
    const candleUpdate = {
        x: [data.map(row => createDate(row[0]))], open: [data.map(row => Number(row[1]))],
        high: [data.map(row => Number(row[2]))], low: [data.map(row => Number(row[3]))],
        close: [data.map(row => Number(row[4]))]
    };
    Plotly.restyle(targetContainer, candleUpdate, 0);
}

async function fetchAllHistoricalData(symbol, endTime = null) {
    const fetchPromises = ALL_TIMEFRAMES.map(async (tf) => {
        try {
            let limit = INITIAL_CANDLES_TO_FETCH;
            if (tf === '1m') { limit = INITIAL_CANDLES_TO_FETCH * 15; }
            let url = `/api/klines?symbol=${symbol}&timeframe=${tf}&limit=${limit}`;
            if (endTime) { url += `&before=${endTime}`; }
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0) {
                allKlinesData[tf] = data.map(k => [k[0], k[1], k[2], k[3], k[4], parseFloat(k[5] || 0)]).sort((a, b) => a[0] - b[0]);
                return true;
            }
            allKlinesData[tf] = [];
            return false;
        } catch (error) { console.error(`Failed to fetch historical data for ${tf}:`, error); allKlinesData[tf] = []; return false; }
    });
    return (await Promise.all(fetchPromises)).every(res => res);
}

async function fetchMoreHistoricalData(targetContainer) {
    if (fetchingMoreData) return;
    fetchingMoreData = true;
    const timeframe = targetContainer === chartContainerTop ? '15m' : '1m';
    const klinesData = allKlinesData[timeframe];
    if (klinesData.length === 0) { fetchingMoreData = false; return; }
    try {
        const earliestTimeCurrent = klinesData[0][0];
        const response = await fetch(`/api/klines?symbol=${currentSymbol}&timeframe=${timeframe}&limit=${CANDLES_TO_FETCH_ON_PAN}&before=${earliestTimeCurrent}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
            const newKlines = data.map(k => [k[0], k[1], k[2], k[3], k[4], parseFloat(k[5] || 0)]).sort((a, b) => a[0] - b[0]);
            const existingTimes = new Set(klinesData.map(k => k[0]));
            const uniqueNewKlines = newKlines.filter(k => !existingTimes.has(k[0]));
            allKlinesData[timeframe] = uniqueNewKlines.concat(klinesData);
            const max_history_limit = timeframe === '1m' ? MAX_HISTORY_1M : MAX_HISTORY;
            if (allKlinesData[timeframe].length > max_history_limit) {
                allKlinesData[timeframe].splice(0, allKlinesData[timeframe].length - max_history_limit);
            }
            if (chartInitialized) updatePlotlyChart(allKlinesData[timeframe], targetContainer);
        }
    } catch (error) { console.error("Failed to fetch more historical data:", error); } 
    finally { fetchingMoreData = false; }
}

function connectAllWebSockets(symbol) {
    ALL_TIMEFRAMES.forEach(tf => {
        if (allWebSockets[tf]) {
            allWebSockets[tf].close();
        }
        const wsSymbol = symbol.toLowerCase();
        const websocketURL = `wss://stream.binance.com:9443/ws/${wsSymbol}@kline_${tf}`;
        const ws = new WebSocket(websocketURL);
        allWebSockets[tf] = ws;
        ws.onopen = () => console.log(`WebSocket connected for ${tf}`);
        ws.onmessage = (event) => {
            if (!chartInitialized || isInTimeTravelMode) return;
            try {
                const k = JSON.parse(event.data).k;
                const newKline = [parseInt(k.t), parseFloat(k.o), parseFloat(k.h), parseFloat(k.l), parseFloat(k.c), parseFloat(k.v) || 0];
                const klinesData = allKlinesData[tf];

                if (klinesData.length === 0) {
                    klinesData.push(newKline);
                } else {
                    const lastKlineTime = klinesData[klinesData.length - 1][0];
                    if (newKline[0] === lastKlineTime) {
                        klinesData[klinesData.length - 1] = newKline;
                    } else if (newKline[0] > lastKlineTime) {
                        klinesData.push(newKline);
                        const max_history_limit = tf === '1m' ? MAX_HISTORY_1M : MAX_HISTORY;
                        if (klinesData.length > max_history_limit) klinesData.shift();
                    }
                }
                if (tf === '15m' && chartContainerTop) {
                    updatePlotlyChart(allKlinesData['15m'], chartContainerTop);
                } else if (tf === '1m' && chartContainerBottom) {
                    updatePlotlyChart(allKlinesData['1m'], chartContainerBottom);
                }
            } catch (error) { console.error(`WS Error for ${tf}:`, error); }
        };
        ws.onclose = (event) => {
            console.log(`WS disconnected for ${tf}. Reason: ${event.reason}`);
            allWebSockets[tf] = null;
            setTimeout(() => { if (!isInTimeTravelMode) connectAllWebSockets(symbol); }, 5000);
        };
        ws.onerror = (err) => { console.error(`WS error for ${tf}:`, err); ws.close(); };
    });
}

function disconnectAllWebSockets() {
    ALL_TIMEFRAMES.forEach(tf => {
        if (allWebSockets[tf]) { allWebSockets[tf].close(); allWebSockets[tf] = null; }
    });
    console.log("All WebSockets disconnected.");
}

async function initializeCharts(symbol, timeTravelEndTime = null) {
    isInTimeTravelMode = !!timeTravelEndTime;
    if(calendarIconButton) calendarIconButton.classList.toggle('active', isInTimeTravelMode);
    if(goLiveButton) goLiveButton.style.display = isInTimeTravelMode ? 'block' : 'none';
    if(timeTravelPickerArea) timeTravelPickerArea.style.display = 'none';
    
    handleDrawingToolToggle('none');

    if (chartContainerTop && chartContainerTop._fullLayout) Plotly.purge(chartContainerTop);
    if (chartContainerBottom && chartContainerBottom._fullLayout) Plotly.purge(chartContainerBottom);
    if(chartContainerTop) chartContainerTop.innerHTML = '<div style="padding: 20px; text-align: center;">데이터 로딩 중...</div>';
    if(chartContainerBottom) chartContainerBottom.innerHTML = '<div style="padding: 20px; text-align: center;">데이터 로딩 중...</div>';
    disconnectAllWebSockets();
    await fetchAllHistoricalData(symbol, timeTravelEndTime);
    await initializePlotly();
    activeAnalysisTimeframe = '15m';
    if (!isInTimeTravelMode) connectAllWebSockets(symbol);
    updateTopBar();
    updateActiveTimeframeButton(activeAnalysisTimeframe);
}

function setupChartEventListeners() {
    document.removeEventListener('keydown', handleKeyDown);
    [chartContainerTop, chartContainerBottom].forEach(container => {
        if (!container) return;
        container.removeEventListener('wheel', handleWheelZoom);
        container.removeEventListener('click', handleChartClick);
        container.removeEventListener('contextmenu', handleContextMenu);
        container.removeEventListener('mousemove', handleMouseMove);
        container.removeEventListener('mouseleave', handleMouseLeave);
        if (container.off) container.off('plotly_relayout');
    });

    document.addEventListener('keydown', handleKeyDown);
    [chartContainerTop, chartContainerBottom].forEach(container => {
        if (!container) return;
        container.addEventListener('wheel', handleWheelZoom, { passive: false });
        container.addEventListener('click', handleChartClick);
        container.addEventListener('contextmenu', handleContextMenu);
        container.addEventListener('mousemove', handleMouseMove);
        container.addEventListener('mouseleave', handleMouseLeave);
        if (container.on) container.on('plotly_relayout', handleRelayout);
    });

    zoomInButton.onclick = () => zoomTime(true);
    zoomOutButton.onclick = () => zoomTime(false);
    zoomPriceUpButton.onclick = () => adjustPriceScale(true);
    zoomPriceDownButton.onclick = () => adjustPriceScale(false);
    document.getElementById('toggle-box-drawing-button').onclick = () => handleDrawingToolToggle('box');
    document.getElementById('measure-tool-btn').onclick = () => handleDrawingToolToggle('measure');
    deleteBoxButton.onclick = handleDeleteBox;
    xAutoRangeToggle.onchange = handleXAutoRangeToggle;
    yAutoRangeToggle.onchange = handleYAutoRangeToggle;
    calendarIconButton.onclick = handleCalendarIconClick;
    loadPastDataButton.onclick = handleLoadPastDataClick;
    goLiveButton.onclick = () => initializeCharts(currentSymbol);
    document.getElementById("set-criterion-btn").onclick = triggerAnalysisAtCenter;
    document.getElementById("full-analysis-btn").onclick = analyzeEntireChart;
    document.getElementById("auto-label-btn").onclick = performAutoLabeling;
    document.getElementById("clear-shapes-btn").onclick = clearAllShapes;
    document.getElementById("find-retracement-btn").onclick = analyzeAndDrawRetracements;
}

// ===================================================================================
// 💥 15분봉-1분봉 연계 분석 엔진
// ===================================================================================
/**
 * 15분봉 되돌림 패턴 이후 1분봉 피봇들을 시각적으로 연결하는 함수
 * @param {number} startTime - 15분 패턴이 완성된 timestamp (ms)
 * @param {object} p3 - 15분봉에서 찾은 T 피봇 객체
 * @returns {object} 마커, 선들, 그리고 1분봉 되돌림 어노테이션들을 포함한 객체
 */
function findAndAnalyzePost15mPattern(startTime, p3) {
    const targetContainer = chartContainerBottom;
    if (!targetContainer || !targetContainer.layout) return { marker: null, lines: [], annotations: [] };

    const klinesData = allKlinesData['1m'];
    const lookaround = parseInt(document.getElementById('lookaround-input').value, 10);
    const { allPivots: rawPivots } = findPivots(0, klinesData, lookaround);
    const consolidatedPivots = consolidatePivots(rawPivots);

    const closestTPivot = consolidatedPivots
        .filter(p => p.type === 'T' && p.time >= p3.time)
        .sort((a, b) => a.time - b.time)[0];

    const result = { marker: null, lines: [], annotations: [] };

    if (closestTPivot) {
        result.marker = {
            name: `marker_15m_T_pivot_${p3.time}`,
            x: createDate(closestTPivot.time),
            y: closestTPivot.price,
            text: '●', 
            showarrow: false,
            font: {
                size: 20,
                color: 'lime'
            },
            yanchor: 'middle',
            xanchor: 'center',
            bgcolor: 'rgba(0,0,0,0.5)',
            bordercolor: 'lime',
            borderwidth: 1
        };

        const markerStartIndex = consolidatedPivots.findIndex(p => p.time === closestTPivot.time);
        
        if (markerStartIndex !== -1) {
            const pivotsToConnect = consolidatedPivots.slice(markerStartIndex, markerStartIndex + 3);

            if (pivotsToConnect.length >= 3) {
                const p1 = pivotsToConnect[0];
                const p2 = pivotsToConnect[1];
                const p3_1m = pivotsToConnect[2];

                if (p1.type === 'T' && p2.type === 'P' && p3_1m.type === 'T') {
                    const move1_size = Math.abs(p2.price - p1.price);
                    const move2_size = Math.abs(p3_1m.price - p2.price);

                    if (move1_size !== 0) {
                        const retracement_ratio = move2_size / move1_size;
                        
                        if (retracement_ratio >= 0.40 && retracement_ratio <= 0.82) {
                            const ratioText = `${(retracement_ratio * 100).toFixed(0)}%`;

                            // ✅ 1) 되돌림 비율 라벨링
                            result.annotations.push({
                                name: `retracement_ratio_1m_${p1.time}`,
                                x: createDate(p3_1m.time),
                                y: p3_1m.price,
                                text: ratioText,
                                showarrow: true,
                                arrowhead: 7,
                                ax: 0,
                                ay: 30,
                                font: { color: 'white', size: 12 },
                                bgcolor: 'rgba(255,140,0,0.7)',
                                bordercolor: 'white',
                                borderwidth: 1
                            });

// ✅ 2) 되돌림 존 재터치 여부 및 상승률 확인
const retraceLow = Math.min(p1.price, p3_1m.price);
                            const endCheckTime = p3_1m.time + 12 * 60 * 60 * 1000; // 12시간 체크

                            const checkCandles = klinesData.filter(
                                k => k[0] >= p3_1m.time && k[0] <= endCheckTime
                            );

                            let didNotRetouch = true;
                            let highestPrice = p3_1m.price;

                            for (const candle of checkCandles) {
                                // 되돌림 존 깨지면 fail (허용 폭 0.5%로 완화)
                                if (candle[3] < retraceLow * 0.995) { 
                                    didNotRetouch = false;
                                    break;
                                }
                                if (candle[2] > highestPrice) {
                                    highestPrice = candle[2];
                                }
                            }
                            
                            // 🚩 상승률 기준을 p3_1m.price로 명확히 함
                            const roseAbove1Percent = (highestPrice >= p3_1m.price * 1.005); // 이 부분을 1.002로 수정

// ✅ 조건 충족 → 체크마크 (수정 버전)
                            if (didNotRetouch && roseAbove1Percent) {
                                result.annotations.push({
                                    name: `validated_pattern_1m_${p1.time}`,
                                    x: createDate(p3_1m.time),
                                    y: p3_1m.price,
                                    text: '', // <-- 텍스트를 빈 문자열로 변경
                                    showarrow: false,
                                    font: { size: 25 }, // <-- 폰트 색상 삭제
                                    yanchor: 'middle',
                                    xanchor: 'center',
                                    ax: 0,
                                    ay: -50,
                                    bgcolor: 'green', // <-- 배경색을 녹색으로 변경
                                    bordercolor: 'black', // <-- 테두리색 추가 (선택사항)
                                    borderpad: 5, // <-- 패딩 추가 (선택사항)
                                });
                            }
                        }
                    }
                }
            }

            // ✅ 순차 연결 선 생성
            for (let i = 0; i < pivotsToConnect.length - 1; i++) {
                const pStart = pivotsToConnect[i];
                const pEnd = pivotsToConnect[i+1];
                
                if (pStart.type !== pEnd.type) {
                    result.lines.push({
                        name: `sequential_line_${pStart.time}_${pEnd.time}`,
                        type: 'line',
                        layer: 'below',
                        xref: 'x', yref: 'y',
                        x0: createDate(pStart.time), y0: pStart.price,
                        x1: createDate(pEnd.time), y1: pEnd.price,
                        line: { color: 'magenta', width: 1.5, dash: 'dot' }
                    });
                }
            }
        }
    }

    return result;
}
// ===================================================================================
// [!!! 최종 수정된 함수 !!!]
// ===================================================================================
function analyzeAndDrawRetracements() {
    if (!chartInitialized) return;

    const targetContainer = activeAnalysisTimeframe === '1m' ? chartContainerBottom : chartContainerTop;
    const klinesData = allKlinesData[activeAnalysisTimeframe];
    const lookaround = parseInt(document.getElementById('lookaround-input').value, 10);

    if (isNaN(lookaround) || lookaround < 1) {
        console.error("민감도(lookaround) 값이 유효하지 않습니다.");
        return;
    }

    clearAnalysisShapes();
    
    console.log(`[롱 전용 최종] 되돌림 패턴 분석 시작 (대상: ${activeAnalysisTimeframe}, 민감도: ${lookaround})...`);

    const { allPivots: rawPivots } = findPivots(0, klinesData, lookaround);
    const consolidatedPivots = consolidatePivots(rawPivots);

    if (consolidatedPivots.length < 3) {
        console.log("분석할 피봇이 3개 미만입니다.");
        return;
    }

    const retracementShapes = [];
    const retracementAnnotations = [];
    const sequentialLines = [];
    const retracementAnnotations1m = []; // 💥 1분봉 되돌림 어노테이션 배열 추가

    for (let i = 0; i < consolidatedPivots.length - 2; i++) {
        const p1 = consolidatedPivots[i];
        const p2 = consolidatedPivots[i+1];
        const p3 = consolidatedPivots[i+2];

        if (p1.type === 'T' && p2.type === 'P' && p3.type === 'T') {
            const move1_size = Math.abs(p2.price - p1.price);
            const move2_size = Math.abs(p3.price - p2.price);

            if (move1_size === 0) continue;
            const retracement_ratio = move2_size / move1_size;
            
            if (retracement_ratio >= 0.50 && retracement_ratio <= 0.85) {
                retracementShapes.push({
                    name: `retracement_line_${i}`,
                    type: 'line',
                    layer: 'above',
                    xref: 'x', yref: 'y',
                    x0: createDate(p2.time), y0: p2.price,
                    x1: createDate(p3.time), y1: p3.price,
                    line: { color: 'lime', width: 2.5, dash: 'solid' }
                });

                if (activeAnalysisTimeframe === '15m') {
                    const result = findAndAnalyzePost15mPattern(p3.time, p3);
                    if (result && result.marker) retracementAnnotations.push(result.marker);
                    if (result && result.lines) sequentialLines.push(...result.lines);
                    if (result && result.annotations) retracementAnnotations1m.push(...result.annotations); // 💥 1분봉 어노테이션 수집
                }
            }
        }
    }

    console.log(`총 ${retracementShapes.length}개의 롱(Long) 되돌림 패턴을 찾았습니다.`);

    const existingTopShapes = (chartContainerTop.layout.shapes || []).filter(s => !s.name?.startsWith('retracement_line_'));
    const existingBottomShapes = (chartContainerBottom.layout.shapes || []).filter(s => !s.name?.startsWith('retracement_line_') && !s.name?.startsWith('sequential_line_'));
    const existingBottomAnnotations = (chartContainerBottom.layout.annotations || []).filter(a => !a.name?.startsWith('marker_15m_T_pivot') && !a.name?.startsWith('retracement_ratio_1m')); // 💥 1분봉 어노테이션도 삭제하도록 수정

    Plotly.relayout(chartContainerTop, { shapes: [...existingTopShapes, ...retracementShapes] });
    Plotly.relayout(chartContainerBottom, {
        shapes: [...existingBottomShapes, ...sequentialLines],
        annotations: [...existingBottomAnnotations, ...retracementAnnotations, ...retracementAnnotations1m] // 💥 1분봉 어노테이션도 함께 그림
    });
}

/**
 * 💥 [신규] 단일 패스(Single-Pass) 전체 분석 알고리즘
 */
function analyzeEntireChart() {
    if (!chartInitialized) return;
    
    const targetContainer = activeAnalysisTimeframe === '1m' ? chartContainerBottom : chartContainerTop;
    const klinesData = allKlinesData[activeAnalysisTimeframe];
    const currentCandleInterval = candleIntervalMillis[activeAnalysisTimeframe];

    clearAnalysisShapes();
    console.log(`단일 패스 분석 엔진 가동 (대상: ${activeAnalysisTimeframe})...`);

    const lookaround = parseInt(document.getElementById('lookaround-input').value, 10);
    if (isNaN(lookaround)) { console.error("Lookaround 값이 유효하지 않습니다."); return; }
    
    const { allPivots: rawPivots } = findPivots(0, klinesData, lookaround);
    const allPivots = consolidatePivots(rawPivots);
    
    if (allPivots.length < 2) { 
        console.log("분석할 피봇이 부족합니다.");
        return; 
    }
    
    const toleranceFactors = {
        lower: 1 - ((parseFloat(document.getElementById('tolerance-input').value) || 0) / 100),
        upper: 1 + ((parseFloat(document.getElementById('tolerance-input').value) || 0) / 100)
    };

    // 1. 메인 시리즈 '지도' 제작
    const mainSeriesMarkers = findMainSeries(allPivots, toleranceFactors, klinesData, currentCandleInterval, targetContainer);
    const mainSeriesIntervals = mainSeriesMarkers.map(ms => ({
        start: new Date(ms.shape.x0).getTime(),
        end: new Date(ms.shape.x1).getTime(),
        series: ms 
    }));

    const consolidatedSeries = [];
    let currentPivotIndex = 0;

    // 2. 모든 피봇을 순차적으로 순회 (건너뛰기 없음)
    while (currentPivotIndex < allPivots.length - 1) {
        const p1 = allPivots[currentPivotIndex];
        
        let isPartOfMainSeries = false;
        let mainSeriesToAdd = null;
        let endPivotIndex = -1;

        // 3. 현재 피봇이 '지도'에 표시된 메인 시리즈의 시작점인지 확인
        for (const interval of mainSeriesIntervals) {
            if (p1.time === interval.start) {
                isPartOfMainSeries = true;
                mainSeriesToAdd = interval.series;
                endPivotIndex = allPivots.findIndex(p => p.time === interval.end);
                break;
            }
        }

        // 4. 메인 시리즈면 노란 실선 추가 후 인덱스 점프, 아니면 서브 시리즈 추가
        if (isPartOfMainSeries && endPivotIndex > currentPivotIndex) {
            consolidatedSeries.push(mainSeriesToAdd);
            currentPivotIndex = endPivotIndex; // 메인 시리즈의 끝으로 점프
        } else {
            const p2 = allPivots[currentPivotIndex + 1];
            consolidatedSeries.push(createSeriesShape(p1, p2, 'SUB'));
            currentPivotIndex++; // 다음 피봇으로 한 칸 이동
        }
    }

    analyzeAndVectorizeAllSeries(consolidatedSeries, allPivots, klinesData);
    const shapesToDraw = consolidatedSeries.map(s => s.shape);
    drawAnalysisResults({ shapes: shapesToDraw, annotations: [] }, targetContainer);

    isFullAnalysisDone = true;
    handleDrawingToolToggle('box');
}


function findMainSeries(allPivots, toleranceFactors, klinesData, candleInterval, targetContainer) {
    const mainSeriesShapes = [];
    const allTroughs = allPivots.filter(p => p.type === 'T');
    const allPeaks = allPivots.filter(p => p.type === 'P');
    let searchFromTime = klinesData.length > 0 ? klinesData[0][0] : 0;
    const endTime = klinesData.length > 0 ? klinesData[klinesData.length - 1][0] : 0;

    while (searchFromTime < endTime) {
        let nextPattern = { startTime: Infinity, type: null };
        for (let i = 0; i < allTroughs.length - 1; i++) {
            if (allTroughs[i].time >= searchFromTime && allTroughs[i + 1].price > allTroughs[i].price) {
                nextPattern = { startTime: allTroughs[i].time, type: 'up' };
                break;
            }
        }
        for (let i = 0; i < allPeaks.length - 1; i++) {
            if (allPeaks[i].time >= searchFromTime && allPeaks[i + 1].price < allPeaks[i].price) {
                if (allPeaks[i].time < nextPattern.startTime) {
                    nextPattern = { startTime: allPeaks[i].time, type: 'down' };
                }
                break;
            }
        }

        if (nextPattern.type === null) break;

        const pivotContext = allPivots.filter(p => p.time >= nextPattern.startTime).slice(0, 20);
        let yellowLine = null;

        if (nextPattern.type === 'up') {
            const analysisResult = analyzeUpwardChannel(pivotContext, allPivots, klinesData, toleranceFactors, targetContainer);
            yellowLine = analysisResult.shapes.find(s => s.name === 'analysis_connecting_line_up');
        } else if (nextPattern.type === 'down') {
            const analysisResult = analyzeDownwardChannel(pivotContext, allPivots, klinesData, toleranceFactors, targetContainer);
            yellowLine = analysisResult.shapes.find(s => s.name === 'analysis_connecting_line_down');
        }

        if (yellowLine) {
            const seriesType = yellowLine.name.includes('up') ? 'MAIN_UP' : 'MAIN_DOWN';
            mainSeriesShapes.push({
                type: seriesType,
                shape: { ...yellowLine, name: `series_${new Date(yellowLine.x0).getTime()}_${new Date(yellowLine.x1).getTime()}`, line: { color: 'rgba(255, 255, 0, 0.6)', width: 2.5, dash: 'solid' } }
            });
            searchFromTime = new Date(yellowLine.x1).getTime();
        } else {
            // 여기가 기존 로직의 버그 지점이었음. (시리즈를 못찾아도 시간을 점프시킴)
            searchFromTime = nextPattern.startTime + (candleInterval || 300000);
        }
    }
    return mainSeriesShapes.sort((a,b) => new Date(a.shape.x0).getTime() - new Date(b.shape.x0).getTime());
}

function createSeriesShape(p1, p2, typePrefix) {
    const isUp = p2.price > p1.price;
    const seriesType = `${typePrefix}_${isUp ? 'UP' : 'DOWN'}`;
    return {
        type: seriesType,
        shape: {
            name: `series_${p1.time}_${p2.time}`,
            type: 'line', layer: 'below', xref: 'x', yref: 'y',
            x0: createDate(p1.time), y0: p1.price,
            x1: createDate(p2.time), y1: p2.price,
            line: { color: isUp ? 'rgba(0, 150, 255, 0.7)' : 'rgba(255, 140, 0, 0.7)', width: 1.5, dash: 'dash' }
        }
    };
}


function analyzeAndVectorizeAllSeries(seriesSequence, allPivots, klinesData){if(!seriesSequence||seriesSequence.length===0){console.log("분석할 시리즈 시퀀스가 없습니다.");return;}
let previousSeriesFeatures=null;const analysisResults=[];const finalTensors=[];for(const series of seriesSequence){const features=extractSeriesFeatures(series,allPivots, klinesData);if(!features)continue;const tensor=calculateTensor(features,previousSeriesFeatures);analysisResults.push(features);finalTensors.push(tensor);previousSeriesFeatures=features;}
console.log(`%c--- 🔥 하이브리드 시리즈 분석 결과 (${analysisResults.length}개) 🔥 ---`,"color: yellow; font-size: 1.2em; font-weight: bold;");console.log(`%c[📊 시리즈 상세 정보]`,"color: cyan; font-weight: bold;");console.table(analysisResults.map(r=>({series_id:r.series_id,series_type:r.series_type,start_time:new Date(r.start_time_timestamp).toLocaleString(),end_time:new Date(r.end_time_timestamp).toLocaleString(),slope:r.slope,total_volume:r.total_volume,pivot_count:r.pivot_count})));console.log(`%c[💥 최종 텐서 시퀀스 (${finalTensors.length} x 141차원)]`,"color: tomato; font-weight: bold; font-size: 1.1em");console.log(finalTensors);}
function extractSeriesFeatures(seriesObject,allPivots, klinesData){const{shape,type}=seriesObject;const startTimeMs=new Date(shape.x0).getTime();const endTimeMs=new Date(shape.x1).getTime();const seriesKlines=klinesData.filter(k=>k[0]>=startTimeMs&&k[0]<=endTimeMs);const internalPivots=allPivots.filter(p=>p.time>startTimeMs&&p.time<endTimeMs);const totalVolume=seriesKlines.reduce((sum,k)=>sum+(k[5]||0),0);const durationSec=(endTimeMs-startTimeMs)/1000;const slope=durationSec>0?(shape.y1-shape.y0)/durationSec:0;const swing=shape.y1-shape.y0;return{series_id:shape.name,series_type:type,start_time_timestamp:startTimeMs,end_time_timestamp:endTimeMs,start_price:shape.y0,end_price:shape.y1,slope:slope.toExponential(2),total_volume:totalVolume.toFixed(2),duration_sec:durationSec,swing:swing,pivot_count:internalPivots.length+2,internal_pivots:internalPivots,};}
function calculateTensor(features,prevFeatures){const vector=new Array(141).fill(0);vector[0]=features.series_type.includes('UP')?1:0;vector[1]=features.series_type.includes('DOWN')?1:0;vector[2]=parseFloat(features.duration_sec);vector[3]=parseFloat(features.slope);vector[4]=parseFloat(features.total_volume);vector[5]=parseFloat(features.pivot_count);const retraceVector=calculateRetracementVector(features,prevFeatures);for(let i=0;i<retraceVector.length;i++){vector[6+i]=retraceVector[i];}
return vector.map(v=>parseFloat(v.toFixed(6)));}
function calculateRetracementVector(features,prevFeatures){const vector=new Array(135).fill(0);const MAX_SEQUENCES_TO_ENCODE=15;const NUM_CATEGORIES=9;if(features.series_type.startsWith('MAIN')){const internalPivotsWithEnds=[{time:features.start_time_timestamp,price:features.start_price,type:features.series_type.includes('UP')?'T':'P'},...features.internal_pivots,{time:features.end_time_timestamp,price:features.end_price,type:features.series_type.includes('UP')?'P':'T'}];let sequenceCount=0;if(internalPivotsWithEnds.length>=3){for(let i=2;i<internalPivotsWithEnds.length&&sequenceCount<MAX_SEQUENCES_TO_ENCODE;i++){const p0=internalPivotsWithEnds[i-2],p1=internalPivotsWithEnds[i-1],p2=internalPivotsWithEnds[i];if(p0.type!==p1.type&&p1.type!==p2.type){let swing_range=0,retracement_amount=0;if(p0.type==='T'){swing_range=p1.price-p0.price;retracement_amount=p1.price-p2.price;}else{swing_range=p0.price-p1.price;retracement_amount=p2.price-p1.price;}
if(swing_range>0){const ratio=retracement_amount/swing_range;const oneHot=getOneHotVectorForRatio(ratio,NUM_CATEGORIES);oneHot.forEach((val,idx)=>{vector[sequenceCount*NUM_CATEGORIES+idx]=val;});sequenceCount++;}}}}}else if(features.series_type.startsWith('SUB')){if(prevFeatures&&prevFeatures.swing!==0){const ratio=Math.abs(features.swing)/Math.abs(prevFeatures.swing);const oneHot=getOneHotVectorForRatio(ratio,NUM_CATEGORIES);oneHot.forEach((val,idx)=>{vector[idx]=val;});}}
return vector;}
function getOneHotVectorForRatio(ratio,numCategories){const oneHotVector=new Array(numCategories).fill(0);const absRatioPercent=Math.abs(ratio*100);let categoryIndex=-1;if(absRatioPercent<35.5)categoryIndex=0;else if(absRatioPercent<58.5)categoryIndex=1;else if(absRatioPercent<74.5)categoryIndex=2;else if(absRatioPercent<91)categoryIndex=3;else if(absRatioPercent<100)categoryIndex=4;else if(absRatioPercent<125)categoryIndex=5;else if(absRatioPercent<200)categoryIndex=6;else if(absRatioPercent<=300)categoryIndex=7;else categoryIndex=8;if(categoryIndex!==-1){oneHotVector[categoryIndex]=1;}
return oneHotVector;}
function triggerAnalysis(timestamp){const targetContainer=activeAnalysisTimeframe==='1m'?chartContainerBottom:chartContainerTop;clearAnalysisShapes();const klinesData=allKlinesData[activeAnalysisTimeframe];const lookaround=parseInt(document.getElementById('lookaround-input').value,10);const tolerancePercent=parseFloat(document.getElementById('tolerance-input').value)||0;const toleranceFactors={lower:1-(tolerancePercent/100),upper:1+(tolerancePercent/100)};if(isNaN(lookaround)||lookaround<1)return;const{allPivots,closestPivots}=findPivots(timestamp,klinesData,lookaround);let shapes=[{name:'analysis_vline',type:'line',xref:'x',yref:'paper',x0:createDate(timestamp),x1:createDate(timestamp),y0:0,y1:1,line:{color:'rgba(255,255,255,0.4)',width:1,dash:'longdash'}}];let annotations=[];if(closestPivots&&closestPivots.length>0){const analysisResult=analyzeChannelAndConnections(closestPivots,allPivots,klinesData,toleranceFactors,targetContainer);shapes.push(...analysisResult.shapes);annotations.push(...analysisResult.annotations);}
drawAnalysisResults({shapes,annotations},targetContainer);}
function drawAnalysisResults({shapes,annotations},targetContainer){const existingAnnotations=(targetContainer.layout.annotations||[]).filter(a=>!a.name?.startsWith('analysis_')&&!a.name?.startsWith('auto_'));const allShapes=(targetContainer.layout.shapes||[]).filter(s=>!s.name?.startsWith('analysis_')&&!s.name?.startsWith('series_'));Plotly.relayout(targetContainer,{shapes:[...allShapes,...shapes],annotations:[...existingAnnotations,...annotations]});}
function clearAnalysisShapes(){[chartContainerTop,chartContainerBottom].forEach(container=>{if(container&&container.layout){const preservedShapes=(container.layout.shapes||[]).filter(s=>!s.name?.startsWith('analysis_')&&!s.name?.startsWith('series_')&&!s.name?.startsWith('retracement_line_'));const preservedAnnotations=(container.layout.annotations||[]).filter(a=>!a.name?.startsWith('analysis_')&&!a.name?.startsWith('auto_'));Plotly.relayout(container,{shapes:preservedShapes,annotations:preservedAnnotations});}});}
function findPivots(timestamp,data,lookaround){const allPivots=[];for(let i=lookaround;i<data.length-lookaround;i++){const windowData=data.slice(i-lookaround,i+lookaround+1);const currentCandle=data[i];if(currentCandle[2]>=Math.max(...windowData.map(d=>d[2]))){allPivots.push({time:currentCandle[0],price:currentCandle[2],type:'P',distance:Math.abs(currentCandle[0]-timestamp)});}
if(currentCandle[3]<=Math.min(...windowData.map(d=>d[3]))){allPivots.push({time:currentCandle[0],price:currentCandle[3],type:'T',distance:Math.abs(currentCandle[0]-timestamp)});}}
if(timestamp===0){allPivots.sort((a,b)=>a.time-b.time);return{allPivots};}
const pivotsOnRight=allPivots.filter(pivot=>pivot.time>timestamp).sort((a,b)=>a.distance-b.distance);return{allPivots,closestPivots:pivotsOnRight.slice(0,20)};}
/**
 * 💥 [버그 수정 최종] 괄호 위치 오류를 바로잡은 완전한 버전
 */
function consolidatePivots(pivots) {
    if (!pivots || pivots.length === 0) return [];
    const consolidated = [];
    let i = 0;
    while (i < pivots.length) {
        const currentPivot = pivots[i];
        const group = [currentPivot];
        let j = i + 1;
        while (j < pivots.length && pivots[j].type === currentPivot.type) {
            group.push(pivots[j]);
            j++;
        }
        if (group.length > 1) {
            if (currentPivot.type === 'P') {
                consolidated.push(group.reduce((max, p) => p.price > max.price ? p : max, group[0]));
            } else {
                consolidated.push(group.reduce((min, p) => p.price < min.price ? p : min, group[0]));
            }
            i = j; 
        } else {
            consolidated.push(currentPivot);
            i++;
        }
    }
    return consolidated;
}
function analyzeChannelAndConnections(closestPivots,allPivots,klinesData,toleranceFactors,targetContainer){const initialShapes=[],initialAnnotations=[];const pivotsSortedByTime=[...closestPivots].sort((a,b)=>a.time-b.time);pivotsSortedByTime.forEach((pivot,index)=>{initialAnnotations.push({name:`analysis_label_${index}`,x:createDate(pivot.time),y:pivot.price,text:pivot.type,showarrow:true,arrowhead:4,ax:0,ay:pivot.type==='P'?-25:25,bgcolor:pivot.type==='P'?'rgba(255,100,0,0.7)':'rgba(0,100,255,0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});if(index>0){const startPivot=pivotsSortedByTime[index-1];initialShapes.push({name:`analysis_zigzag_${index-1}`,type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(startPivot.time),y0:startPivot.price,x1:createDate(pivot.time),y1:pivot.price,line:{color:'rgba(255,255,255,0.5)',width:1,dash:'dash'}});}});const upTrendResult=analyzeUpwardChannel(closestPivots,allPivots,klinesData,toleranceFactors,targetContainer);const downTrendResult=analyzeDownwardChannel(closestPivots,allPivots,klinesData,toleranceFactors,targetContainer);return{shapes:[...initialShapes,...upTrendResult.shapes,...downTrendResult.shapes],annotations:[...initialAnnotations,...upTrendResult.annotations,...downTrendResult.annotations]};}
function analyzeUpwardChannel(closestPivots,allPivots,klinesData,toleranceFactors,targetContainer){const shapes=[],annotations=[];const troughs=closestPivots.filter(p=>p.type==='T').sort((a,b)=>a.time-b.time);if(troughs.length<2)return{shapes,annotations};const t1=troughs[0],t2=troughs[1];if(t2.price<t1.price){annotations.push({name:'analysis_label_uptrend_end_pre',x:createDate(t2.time),y:t2.price,text:'<b>상승 추세 종료 (T < T-1)</b>',showarrow:true,arrowhead:7,ax:0,ay:40,bgcolor:'rgba(139, 0, 0, 0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});return{shapes,annotations};}
const slope=(t2.price-t1.price)/(t2.time-t1.time);if(t2.time===t1.time)return{shapes,annotations};const xRange=targetContainer._fullLayout.xaxis.range,xStartTimestamp=new Date(xRange[0]).getTime(),xEndTimestamp=new Date(xRange[1]).getTime()+(24*60*60*1000);shapes.push({name:'analysis_trendline_up',type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(xStartTimestamp),y0:slope*(xStartTimestamp-t1.time)+t1.price,x1:createDate(xEndTimestamp),y1:slope*(xEndTimestamp-t1.time)+t1.price,line:{color:'cyan',width:1.5,dash:'dot'}});const firstP=closestPivots.filter(p=>p.type==='P').sort((a,b)=>a.time-b.time)[0];const breakthroughP=allPivots.filter(p=>p.type==='P'&&p.time>firstP?.time&&p.price>firstP?.price).sort((a,b)=>a.time-b.time)[0];if(!breakthroughP)return{shapes,annotations};annotations.push({name:`analysis_label_p_minus`,x:createDate(breakthroughP.time),y:breakthroughP.price,text:'P-',showarrow:true,arrowhead:4,ax:0,ay:-35,bgcolor:'rgba(255,20,147,0.7)',font:{color:'white',size:14}});shapes.push({name:'analysis_parallel_line_up',type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(xStartTimestamp),y0:slope*(xStartTimestamp-breakthroughP.time)+breakthroughP.price,x1:createDate(xEndTimestamp),y1:slope*(xEndTimestamp-breakthroughP.time)+breakthroughP.price,line:{color:'cyan',width:1.5,dash:'dot'}});let lowerBreakoutCandle=null,upperBreakoutCandle=null;const startIndex=klinesData.findIndex(k=>k[0]>t2.time);if(startIndex!==-1){for(let i=startIndex;i<klinesData.length;i++){const candle=klinesData[i],candleTime=candle[0],candleHigh=candle[2],candleLow=candle[3];if(!lowerBreakoutCandle){const lowerBoundary=slope*(candleTime-t1.time)+t1.price;if(candleLow<(lowerBoundary*toleranceFactors.lower))lowerBreakoutCandle=candle;}
if(!upperBreakoutCandle&&candleTime>firstP?.time){const upperBoundary=slope*(candleTime-firstP.time)+firstP.price;if(candleHigh>(upperBoundary*toleranceFactors.upper))upperBreakoutCandle=candle;}
if(lowerBreakoutCandle&&(upperBreakoutCandle||candleTime<=firstP?.time))break;if(lowerBreakoutCandle&&upperBreakoutCandle)break;}}
if(lowerBreakoutCandle)annotations.push({name:'analysis_label_break_down_upchannel',x:createDate(lowerBreakoutCandle[0]),y:lowerBreakoutCandle[3],text:'<b>하단 이탈</b>',showarrow:true,arrowhead:7,ax:0,ay:40,bgcolor:'rgba(255,140,0,0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});if(upperBreakoutCandle)annotations.push({name:'analysis_label_break_up_upchannel',x:createDate(upperBreakoutCandle[0]),y:upperBreakoutCandle[2],text:'<b>상단 돌파</b>',showarrow:true,arrowhead:7,ax:0,ay:-40,bgcolor:'rgba(0,150,255,0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});const firstBreakoutTime=[lowerBreakoutCandle,upperBreakoutCandle].filter(Boolean).reduce((min,c)=>Math.min(min,c[0]),Infinity);const channelEndTime=(firstBreakoutTime===Infinity)?klinesData[klinesData.length-1][0]:firstBreakoutTime;const peaksInChannel=allPivots.filter(p=>p.type==='P'&&p.time>=t1.time&&p.time<channelEndTime);if(peaksInChannel.length>0){const highestPeakInChannel=peaksInChannel.reduce((max,p)=>p.price>max.price?p:max);shapes.push({name:'analysis_connecting_line_up',type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(t1.time),y0:t1.price,x1:createDate(highestPeakInChannel.time),y1:highestPeakInChannel.price});}
return{shapes,annotations};}
function analyzeDownwardChannel(closestPivots,allPivots,klinesData,toleranceFactors,targetContainer){const shapes=[],annotations=[];const peaks=closestPivots.filter(p=>p.type==='P').sort((a,b)=>a.time-b.time);if(peaks.length<2)return{shapes,annotations};const p1=peaks[0],p2=peaks[1];if(p2.price>p1.price){annotations.push({name:'analysis_label_downtrend_end_pre',x:createDate(p2.time),y:p2.price,text:'<b>하락 추세 종료 (P > P-1)</b>',showarrow:true,arrowhead:7,ax:0,ay:-40,bgcolor:'rgba(0, 100, 0, 0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});return{shapes,annotations};}
const slope=(p2.price-p1.price)/(p2.time-p1.time);if(p2.time===p1.time)return{shapes,annotations};const xRange=targetContainer._fullLayout.xaxis.range,xStartTimestamp=new Date(xRange[0]).getTime(),xEndTimestamp=new Date(xRange[1]).getTime()+(24*60*60*1000);shapes.push({name:'analysis_trendline_down',type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(xStartTimestamp),y0:slope*(xStartTimestamp-p1.time)+p1.price,x1:createDate(xEndTimestamp),y1:slope*(xEndTimestamp-p1.time)+p1.price,line:{color:'magenta',width:1.5,dash:'dot'}});const firstT=closestPivots.filter(p=>p.type==='T').sort((a,b)=>a.time-b.time)[0];const breakthroughT=allPivots.filter(p=>p.type==='T'&&p.time>firstT?.time&&p.price<firstT?.price).sort((a,b)=>a.distance-b.distance)[0];if(!breakthroughT)return{shapes,annotations};annotations.push({name:`analysis_label_t_plus`,x:createDate(breakthroughT.time),y:breakthroughT.price,text:'T+',showarrow:true,arrowhead:4,ax:0,ay:35,bgcolor:'rgba(20,255,147,0.7)',font:{color:'white',size:14}});shapes.push({name:'analysis_parallel_line_down',type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(xStartTimestamp),y0:slope*(xStartTimestamp-breakthroughT.time)+breakthroughT.price,x1:createDate(xEndTimestamp),y1:slope*(xEndTimestamp-breakthroughT.time)+breakthroughT.price,line:{color:'magenta',width:1.5,dash:'dot'}});let upperBreakoutCandle=null,lowerBreakoutCandle=null;const startIndex=klinesData.findIndex(k=>k[0]>p2.time);if(startIndex!==-1){for(let i=startIndex;i<klinesData.length;i++){const candle=klinesData[i],candleTime=candle[0],candleHigh=candle[2],candleLow=candle[3];if(!upperBreakoutCandle){const upperBoundary=slope*(candleTime-p1.time)+p1.price;if(candleHigh>(upperBoundary*toleranceFactors.upper))upperBreakoutCandle=candle;}
if(!lowerBreakoutCandle&&candleTime>firstT?.time){const lowerBoundary=slope*(candleTime-firstT.time)+firstT.price;if(candleLow<(lowerBoundary*toleranceFactors.lower))lowerBreakoutCandle=candle;}
if(upperBreakoutCandle&&(lowerBreakoutCandle||candleTime<=firstT?.time))break;if(upperBreakoutCandle&&lowerBreakoutCandle)break;}}
if(upperBreakoutCandle)annotations.push({name:'analysis_label_break_up_downchannel',x:createDate(upperBreakoutCandle[0]),y:upperBreakoutCandle[2],text:'<b>상단 돌파</b>',showarrow:true,arrowhead:7,ax:0,ay:-40,bgcolor:'rgba(0,150,255,0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});if(lowerBreakoutCandle)annotations.push({name:'analysis_label_break_down_downchannel',x:createDate(lowerBreakoutCandle[0]),y:lowerBreakoutCandle[3],text:'<b>하단 이탈</b>',showarrow:true,arrowhead:7,ax:0,ay:40,bgcolor:'rgba(255,140,0,0.7)',bordercolor:'white',borderwidth:1,font:{color:'white',size:12}});const firstBreakoutTime=[upperBreakoutCandle,lowerBreakoutCandle].filter(Boolean).reduce((min,c)=>Math.min(min,c[0]),Infinity);const channelEndTime=(firstBreakoutTime===Infinity)?klinesData[klinesData.length-1][0]:firstBreakoutTime;const troughsInChannel=allPivots.filter(p=>p.type==='T'&&p.time>=p1.time&&p.time<channelEndTime);if(troughsInChannel.length>0){const lowestTroughInChannel=troughsInChannel.reduce((min,p)=>p.price<min.price?p:min);shapes.push({name:'analysis_connecting_line_down',type:'line',layer:'below',xref:'x',yref:'y',x0:createDate(p1.time),y0:p1.price,x1:createDate(lowestTroughInChannel.time),y1:lowestTroughInChannel.price});}
return{shapes,annotations};}
function performAutoLabeling(){if(!chartInitialized)return;const lookaround=parseInt(document.getElementById('lookaround-input').value,10);if(isNaN(lookaround)||isNaN(lookaround))return;[chartContainerTop,chartContainerBottom].forEach(container=>{const timeframe=(container===chartContainerTop)?'15m':'1m';const klines=allKlinesData[timeframe];const{allPivots:rawPivots}=findPivots(0,klines,lookaround);const consolidatedPivots=consolidatePivots(rawPivots);const annotations=consolidatedPivots.map((pivot,i)=>({name:`auto_${pivot.type}_${i}`,x:createDate(pivot.time),y:pivot.price,text:pivot.type,showarrow:true,arrowhead:4,ax:0,ay:pivot.type==='P'?-20:20,font:{size:10,color:pivot.type==='P'?'orange':'skyblue'},bgcolor:'rgba(0,0,0,0.7)'}));const existingAnnotations=(container.layout.annotations||[]).filter(a=>!a.name?.startsWith('auto_'));Plotly.relayout(container,{annotations:[...existingAnnotations,...annotations]});console.log(`자동 라벨링 완료: ${timeframe} 차트 (${annotations.length}개)`);});}

// ===================================================================================
// 유틸리티 및 이벤트 핸들러
// ===================================================================================
function handleDrawingToolToggle(toolToToggle){const boxButton=document.getElementById('toggle-box-drawing-button');const measureButton=document.getElementById('measure-tool-btn');const wasBoxEnabled=isBoxDrawingEnabled;const wasMeasureEnabled=isMeasureModeEnabled;isBoxDrawingEnabled=false;isMeasureModeEnabled=false;measureStartPoint=null;currentBoxFirstPoint=null;clearMeasureShapes();if(toolToToggle==='box'&&!wasBoxEnabled){isBoxDrawingEnabled=true;}else if(toolToToggle==='measure'&&!wasMeasureEnabled){isMeasureModeEnabled=true;}
const boxButtonText=isFullAnalysisDone?'💎 시리즈 선택':'📦 Box';boxButton.textContent=isBoxDrawingEnabled?'✋ 선택 해제':boxButtonText;boxButton.classList.toggle('active',isBoxDrawingEnabled);measureButton.classList.toggle('active',isMeasureModeEnabled);}
function handleChartClick(event){const clickedChartContainer=event.target.closest('#chart-container-top')||event.target.closest('#chart-container-bottom');if(!clickedChartContainer||!chartInitialized||event.target.closest('.select-outline'))return;const clickData=getClickCoordinates(event,clickedChartContainer);if(!clickData)return;if(isMeasureModeEnabled){if(!measureStartPoint){clearMeasureShapes();measureStartPoint={...clickData,chart:clickedChartContainer};}else{measureStartPoint=null;}
return;}
if(isBoxDrawingEnabled&&event.button===0){if(!currentBoxFirstPoint){currentBoxFirstPoint=clickData;}else{if(selectionBox){drawnBoxes=drawnBoxes.filter(b=>b.id!==selectionBox.id);selectionBox=null;selectedSeries=[];}
const boxId=isFullAnalysisDone?'series_selection_box_'+Date.now():BOX_SHAPE_NAME_PREFIX+Date.now();const newBoxShape={id:boxId,name:boxId,type:'rect',layer:'below',xref:'x',yref:'y',x0:createDate(Math.min(currentBoxFirstPoint.time.getTime(),clickData.time.getTime())),y0:Math.min(currentBoxFirstPoint.price,clickData.price),x1:createDate(Math.max(currentBoxFirstPoint.time.getTime(),clickData.time.getTime())),y1:Math.max(currentBoxFirstPoint.price,clickData.price),fillcolor:'rgba(0,123,255,0.2)',line:{color:'rgba(0,123,255,0.7)',width:1},};if(isFullAnalysisDone){newBoxShape.fillcolor='rgba(255,0,0,0.1)';newBoxShape.line={color:'rgba(255,0,0,0.7)',width:1.5,dash:'dash'};selectionBox=newBoxShape;const allAnalyzedShapes=(clickedChartContainer.layout.shapes||[]).filter(s=>s.name?.startsWith('series_'));const selectionX0=new Date(selectionBox.x0).getTime(),selectionX1=new Date(selectionBox.x1).getTime();selectedSeries=allAnalyzedShapes.map(s=>{const type=s.name.includes('MAIN')?(s.line.color.includes('255,255,0')?(s.y1>s.y0?'MAIN_UP':'MAIN_DOWN'):'SUB'):(s.y1>s.y0?'SUB_UP':'SUB_DOWN');return{type,shape:s};}).filter(s_obj=>{const shapeX0=new Date(s_obj.shape.x0).getTime(),shapeX1=new Date(s_obj.shape.x1).getTime();return Math.max(selectionX0,shapeX0)<=Math.min(selectionX1,shapeX1);});const lookaroundValue=parseInt(document.getElementById('lookaround-input').value,10);const klinesData=allKlinesData[clickedChartContainer===chartContainerTop?'15m':'1m'];const allPivots=consolidatePivots(findPivots(0,klinesData,lookaroundValue).allPivots);analyzeAndVectorizeAllSeries(selectedSeries,allPivots,klinesData);}else{drawnBoxes.push(newBoxShape);}
currentBoxFirstPoint=null;Plotly.relayout(clickedChartContainer,{shapes:getCurrentlyVisibleShapes(clickedChartContainer)});}}else{event.preventDefault();event.stopImmediatePropagation();activeAnalysisTimeframe=clickedChartContainer===chartContainerTop?'15m':'1m';updateActiveTimeframeButton(activeAnalysisTimeframe);updateTopBar();triggerAnalysis(clickData.time.getTime());}}
function triggerAnalysisAtCenter(){if(!chartInitialized)return;const targetContainer=activeAnalysisTimeframe==='1m'?chartContainerBottom:chartContainerTop;const currentXRange=targetContainer._fullLayout.xaxis.range;const centerX=new Date(currentXRange[0]).getTime()+(new Date(currentXRange[1]).getTime()-new Date(currentXRange[0]).getTime())/2;triggerAnalysis(centerX);}
function isPointInShape(point,shape){if(!point||!shape||shape.type!=='rect')return false;const t=point.time.getTime(),p=point.price;const x0=new Date(shape.x0).getTime(),x1=new Date(shape.x1).getTime();return t>=Math.min(x0,x1)&&t<=Math.max(x0,x1)&&p>=Math.min(shape.y0,shape.y1)&&p<=Math.max(shape.y0,shape.y1);}
function handleContextMenu(event){event.preventDefault();const clickedChartContainer=event.target.closest('#chart-container-top')||event.target.closest('#chart-container-bottom');if(!clickedChartContainer||!chartInitialized)return;const clickData=getClickCoordinates(event,clickedChartContainer);contextMenu.style.display='none';deleteBoxButton.style.display='none';contextMenuTargetInfo=null;if(clickData){const clickedBox=drawnBoxes.find(box=>isPointInShape(clickData,box));if(clickedBox&&(!selectionBox||clickedBox.id!==selectionBox.id)){deleteBoxButton.style.display='block';contextMenuTargetInfo={type:'box',id:clickedBox.id,chart:clickedChartContainer};contextMenu.style.display='block';contextMenu.style.left=`${event.clientX}px`;contextMenu.style.top=`${event.clientY}px`;document.addEventListener('click',()=>contextMenu.style.display='none',{once:true});}}}
function handleDeleteBox(){if(contextMenuTargetInfo?.type==='box'&&contextMenuTargetInfo.id){drawnBoxes=drawnBoxes.filter(box=>box.id!==contextMenuTargetInfo.id);const targetChart=contextMenuTargetInfo.chart;Plotly.relayout(targetChart,{shapes:getCurrentlyVisibleShapes(targetChart)});}
contextMenu.style.display='none';}
function handleMouseMove(e){if(!chartInitialized)return;const eventChartContainer=e.target.closest('#chart-container-top')||e.target.closest('#chart-container-bottom');if(!eventChartContainer)return handleMouseLeave();const coords=getClickCoordinates(e,eventChartContainer);if(!coords)return handleMouseLeave();if(isMeasureModeEnabled&&measureStartPoint){clearMeasureShapes();const start=measureStartPoint,end=coords;const priceDiff=end.price-start.price,percentChange=(priceDiff/start.price)*100,timeDiff=end.time.getTime()-start.time.getTime();const startTime=Math.min(start.time.getTime(),end.time.getTime()),endTime=Math.max(start.time.getTime(),end.time.getTime());const klinesData=allKlinesData[activeAnalysisTimeframe];const barCount=klinesData.filter(k=>k[0]>=startTime&&k[0]<=endTime).length;const infoText=`${priceDiff.toFixed(2)} (${percentChange.toFixed(2)}%)<br>${barCount} bars, ${formatTimeDuration(timeDiff)}`;const lineShape={name:'measure_line',type:'line',layer:'above',xref:'x',yref:'y',x0:start.time,y0:start.price,x1:end.time,y1:end.price,line:{color:'rgba(255,255,255,0.7)',width:1.5,dash:'dash'}};const annotation={name:'measure_info_text',x:end.time,y:end.price,text:infoText,showarrow:false,font:{color:'white',size:12},align:end.time>start.time?'left':'right',xanchor:end.time>start.time?'left':'right',yanchor:'middle',ax:10,bgcolor:'rgba(0,0,0,0.7)',borderpad:4};[chartContainerTop,chartContainerBottom].forEach(chartDiv=>{const existingShapes=(chartDiv.layout.shapes||[]).filter(s=>!s.name?.startsWith("measure_"));const existingAnnotations=(chartDiv.layout.annotations||[]).filter(a=>!a.name?.startsWith("measure_"));Plotly.relayout(chartDiv,{shapes:[...existingShapes,lineShape],annotations:[...existingAnnotations,annotation]});});return;}
[chartContainerTop,chartContainerBottom].forEach(chartDiv=>{if(!chartDiv||!chartDiv.layout)return;const existingShapes=(chartDiv.layout.shapes||[]).filter(s=>!s.name?.startsWith("crosshair"));const existingAnnotations=(chartDiv.layout.annotations||[]).filter(a=>!a.name?.startsWith("crosshair"));const crosshairShapes=[{name:"crosshair_v",type:"line",visible:true,line:CROSSHAIR_LINE_STYLE,yref:"paper",y0:0,y1:1,x0:coords.time.getTime(),x1:coords.time.getTime()},{name:"crosshair_h",type:"line",visible:true,line:CROSSHAIR_LINE_STYLE,xref:"paper",x0:0,x1:1,y0:coords.price,y1:coords.price}];const priceAnnotation={name:"crosshair_price_label",x:1.01,xref:"paper",y:coords.price,yref:"y",text:coords.price.toFixed(2),showarrow:false,font:{color:"black",size:10},bgcolor:"grey",borderpad:2,align:'left'};const timeAnnotation={name:"crosshair_time_label",x:coords.time,xref:"x",y:1.01,yref:"paper",text:coords.time.toLocaleString([],{year:'2-digit',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',hour12:false}),showarrow:false,font:{color:"black",size:10},bgcolor:"grey",borderpad:2};Plotly.relayout(chartDiv,{shapes:[...existingShapes,...crosshairShapes],annotations:[...existingAnnotations,priceAnnotation,timeAnnotation]});});}
function handleMouseLeave(){if(!chartInitialized)return;[chartContainerTop,chartContainerBottom].forEach(chartDiv=>{if(!chartDiv||!chartDiv.layout)return;const preservedShapes=(chartDiv.layout.shapes||[]).filter(s=>!s.name?.startsWith("crosshair"));const preservedAnnotations=(chartDiv.layout.annotations||[]).filter(a=>!a.name?.startsWith("crosshair"));Plotly.relayout(chartDiv,{shapes:preservedShapes,annotations:preservedAnnotations});});}
function handleKeyDown(event){if(document.activeElement.tagName==='INPUT')return;const key=event.key.toLowerCase();let preventDefault=true;if(key==='c')triggerAnalysisAtCenter();else if(key==='+'||key==='=')zoomTime(true);else if(key==='-'||key==='_')zoomTime(false);else if(key==='arrowup'||key==='w')panPrice(0.05);else if(key==='arrowdown'||key==='s')panPrice(-0.05);else if(key==='arrowleft'||key==='a')panTime(-PAN_FRACTION);else if(key==='arrowright'||key==='d')panTime(PAN_FRACTION);else if(key==='r')analyzeAndDrawRetracements(); // [추가] 'R' 키 단축키
else preventDefault=false;if(preventDefault)event.preventDefault();}
function handleWheelZoom(event){if(!chartInitialized)return;event.preventDefault();zoomTime(event.deltaY>0);}
function getClickCoordinates(e,targetContainer){const fullLayout=targetContainer._fullLayout;if(!fullLayout?.xaxis?._length)return null;const bRect=targetContainer.getBoundingClientRect();const x=e.clientX-bRect.left;const y=e.clientY-bRect.top;const xa=fullLayout.xaxis;const ya=fullLayout.yaxis;const dataX=xa.p2d(x-fullLayout.margin.l);const dataY=ya.p2d(y-fullLayout.margin.t);if(dataX<xa.range[0]||dataX>xa.range[1]||dataY<ya.range[0]||dataY>ya.range[1]){return null;}
return{time:createDate(dataX),price:dataY};}
function getCurrentlyVisibleShapes(targetContainer){const analysisAndSeriesShapes=(targetContainer.layout.shapes||[]).filter(s=>!s.name?.startsWith(BOX_SHAPE_NAME_PREFIX)&&s.id!==selectionBox?.id);const allShapes=[...drawnBoxes,...analysisAndSeriesShapes];if(selectionBox){allShapes.push(selectionBox);}
return allShapes;}
function checkForPastDataFetch(newRange){if(fetchingMoreData||isInTimeTravelMode)return;const viewportStartTime=new Date(newRange[0]).getTime();const oldestTime15m=allKlinesData['15m'].length>0?allKlinesData['15m'][0][0]:Infinity;if((viewportStartTime-oldestTime15m)<=(candleIntervalMillis['15m']*50)){fetchMoreHistoricalData(chartContainerTop);}
const oldestTime1m=allKlinesData['1m'].length>0?allKlinesData['1m'][0][0]:Infinity;if((viewportStartTime-oldestTime1m)<=(candleIntervalMillis['1m']*50)){fetchMoreHistoricalData(chartContainerBottom);}}
function updateXAxisRangeForAllCharts(newRange){if(isRelayouting||!chartInitialized)return;isRelayouting=true;Promise.all([Plotly.relayout(chartContainerTop,{'xaxis.range':newRange}),Plotly.relayout(chartContainerBottom,{'xaxis.range':newRange})]).finally(()=>{isRelayouting=false;});}
function zoomTime(zoomIn){if(!chartInitialized)return;if(isXAutoRangeEnabled){isXAutoRangeEnabled=false;xAutoRangeToggle.checked=false;}
const range=chartContainerTop._fullLayout.xaxis.range.map(d=>new Date(d).getTime());const change=(range[1]-range[0])*X_AXIS_ZOOM_FACTOR*(zoomIn?-0.5:0.5);const newRange=[createDate(range[0]+change),createDate(range[1]-change)];updateXAxisRangeForAllCharts(newRange);}
function panTime(fraction){if(!chartInitialized)return;if(isXAutoRangeEnabled){isXAutoRangeEnabled=false;xAutoRangeToggle.checked=false;}
const range=chartContainerTop._fullLayout.xaxis.range.map(d=>new Date(d).getTime());const move=(range[1]-range[0])*fraction;const newRange=[createDate(range[0]+move),createDate(range[1]+move)];updateXAxisRangeForAllCharts(newRange);if(fraction<0){checkForPastDataFetch(newRange);}}
function adjustPriceScale(zoomIn){if(!chartInitialized)return;if(isYAutoRangeEnabled){isYAutoRangeEnabled=false;yAutoRangeToggle.checked=false;}
const rangeTop=chartContainerTop._fullLayout.yaxis.range;const rangeBottom=chartContainerBottom._fullLayout.yaxis.range;const changeTop=(rangeTop[1]-rangeTop[0])*Y_AXIS_ZOOM_FACTOR*(zoomIn?-0.5:0.5);const changeBottom=(rangeBottom[1]-rangeBottom[0])*Y_AXIS_ZOOM_FACTOR*(zoomIn?-0.5:0.5);Plotly.relayout(chartContainerTop,{'yaxis.range':[rangeTop[0]-changeTop,rangeTop[1]+changeTop]});Plotly.relayout(chartContainerBottom,{'yaxis.range':[rangeBottom[0]-changeBottom,rangeBottom[1]+changeBottom]});}
function panPrice(fraction){if(!chartInitialized)return;if(isYAutoRangeEnabled){isYAutoRangeEnabled=false;yAutoRangeToggle.checked=false;}
const rangeTop=chartContainerTop._fullLayout.yaxis.range;const rangeBottom=chartContainerBottom._fullLayout.yaxis.range;const moveTop=(rangeTop[1]-rangeTop[0])*fraction;const moveBottom=(rangeBottom[1]-rangeBottom[0])*fraction;Plotly.relayout(chartContainerTop,{'yaxis.range':[rangeTop[0]+moveTop,rangeTop[1]+moveTop]});Plotly.relayout(chartContainerBottom,{'yaxis.range':[rangeBottom[0]+moveBottom,rangeBottom[1]+moveBottom]});}
function handleCalendarIconClick(){timeTravelPickerArea.style.display=timeTravelPickerArea.style.display==='none'?'flex':'none';if(timeTravelPickerArea.style.display==='flex'){datetimePicker.value=new Date(Date.now()-new Date().getTimezoneOffset()*60000).toISOString().slice(0,16);}}
function handleLoadPastDataClick(){const datetimeString=datetimePicker.value;if(!datetimeString){alert("시간을 선택해주세요.");return;}
const selectedTime=new Date(datetimeString).getTime();console.log(`시간 여행 모드 시작: ${new Date(selectedTime).toLocaleString()}`);initializeCharts(currentSymbol,selectedTime);}
function handleXAutoRangeToggle(){isXAutoRangeEnabled=xAutoRangeToggle.checked;if(chartInitialized){const layoutUpdate={'xaxis.autorange':isXAutoRangeEnabled};if(!isXAutoRangeEnabled){const data15m=allKlinesData['15m'];if(data15m.length>0){const newRange=[createDate(data15m[Math.max(0,data15m.length-MAX_DISPLAY_CANDLES)][0]),createDate(data15m[data15m.length-1][0])];layoutUpdate['xaxis.range']=newRange;updateXAxisRangeForAllCharts(newRange);}}else{Plotly.relayout(chartContainerTop,layoutUpdate);Plotly.relayout(chartContainerBottom,layoutUpdate);}}}
function handleYAutoRangeToggle(){isYAutoRangeEnabled=yAutoRangeToggle.checked;if(chartInitialized){const layoutUpdate={'yaxis.autorange':isYAutoRangeEnabled};Plotly.relayout(chartContainerTop,layoutUpdate);Plotly.relayout(chartContainerBottom,layoutUpdate);}}
function handleRelayout(eventData){if(isRelayouting)return;if(eventData['xaxis.range[0]']||eventData['xaxis.range']){const newRange=eventData['xaxis.range']||[eventData['xaxis.range[0]'],eventData['xaxis.range[1]']];if(!newRange||newRange.length!==2)return;updateXAxisRangeForAllCharts(newRange);const currentRange=chartContainerTop._fullLayout.xaxis.range.map(d=>new Date(d).getTime());if(new Date(newRange[0]).getTime()<currentRange[0]){checkForPastDataFetch(newRange);}}}
function updateActiveTimeframeButton(activeTf){if(timeframeButtonsContainer){timeframeButtonsContainer.querySelectorAll('button').forEach(b=>b.classList.toggle('active',b.dataset.timeframe===activeTf));}}
function clearMeasureShapes(){[chartContainerTop,chartContainerBottom].forEach(chartDiv=>{if(chartDiv&&chartDiv.layout){const preservedShapes=(chartDiv.layout.shapes||[]).filter(s=>!s.name?.startsWith("measure_"));const preservedAnnotations=(chartDiv.layout.annotations||[]).filter(a=>!a.name?.startsWith("measure_"));Plotly.relayout(chartDiv,{shapes:preservedShapes,annotations:preservedAnnotations});}});}
function formatTimeDuration(ms){if(ms<0)ms=-ms;const days=Math.floor(ms/(1000*60*60*24));ms%=(1000*60*60*24);const hours=Math.floor(ms/(1000*60*60));ms%=(1000*60*60);const minutes=Math.floor(ms/(1000*60));let result='';if(days>0)result+=`${days}d `;if(hours>0)result+=`${hours}h `;if(minutes>0||(days===0&&hours===0))result+=`${minutes}m`;return result.trim();}
function clearAllShapes(){drawnBoxes=[];currentBoxFirstPoint=null;selectionBox=null;selectedSeries=[];isFullAnalysisDone=false;handleDrawingToolToggle('none');clearAnalysisShapes();toggleBoxDrawingButton.textContent = '📦 Box';}

// ===================================================================================
// DOMContentLoaded 이벤트
// ===================================================================================
document.addEventListener('DOMContentLoaded', () => {
    chartContainerTop = document.getElementById('chart-container-top');
    chartContainerBottom = document.getElementById('chart-container-bottom');
    xAutoRangeToggle = document.getElementById('x-autorange-toggle-top');
    yAutoRangeToggle = document.getElementById('y-autorange-toggle-top');
    zoomInButton = document.getElementById('zoom-in');
    zoomOutButton = document.getElementById('zoom-out');
    zoomPriceUpButton = document.getElementById('zoom-price-up');
    zoomPriceDownButton = document.getElementById('zoom-price-down');
    contextMenu = document.getElementById('chart-context-menu');
    timeframeButtonsContainer = document.getElementById('timeframe-buttons');
    calendarIconButton = document.getElementById('calendar-icon-button');
    timeTravelPickerArea = document.getElementById('time-travel-picker-area');
    datetimePicker = document.getElementById('datetime-picker');
    loadPastDataButton = document.getElementById('load-past-data-button');
    goLiveButton = document.getElementById('go-live-button');
    toggleBoxDrawingButton = document.getElementById('toggle-box-drawing-button');
    deleteBoxButton = document.getElementById('delete-box');

    timeframeButtonsContainer.addEventListener('click', async (event) => {
        if (event.target.tagName === 'BUTTON' && event.target.dataset.timeframe) {
            const newTimeframe = event.target.dataset.timeframe;
            if (newTimeframe !== activeAnalysisTimeframe) {
                activeAnalysisTimeframe = newTimeframe;
                updateTopBar();
                updateActiveTimeframeButton(newTimeframe);
                console.log(`Active analysis timeframe changed to: ${newTimeframe}`);
            }
        }
    });
    initializeCharts(currentSymbol);
});
</script>
</body>
</html>