<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÌÜµÌï© Í≥†Í∏â Î∂ÑÏÑù Ï∞®Ìä∏</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            background-color: black; color: white; font-family: sans-serif;
            margin: 0; padding: 0; display: flex; flex-direction: column;
            align-items: center; min-height: 100vh;
        }
        #integrated-controls-panel {
            width: 100%; background-color: #1e1e1e; color: #ccc;
            padding: 4px 10px; display: flex; flex-wrap: wrap;
            justify-content: flex-start; align-items: center;
            box-sizing: border-box; border-bottom: 1px solid #444;
            position: sticky; top: 0; z-index: 1001; gap: 12px;
        }
        .ic-group { display: flex; align-items: center; gap: 6px; padding: 2px 8px; border-right: 1px solid #444; }
        .ic-group:last-child { border-right: none; }
        #integrated-controls-panel span,
        #integrated-controls-panel label {
            font-size: 0.85em; white-space: nowrap; margin: 0;
        }
        #integrated-controls-panel input[type="checkbox"],
        #integrated-controls-panel input[type="number"] {
            vertical-align: middle; margin: 0 2px 0 0; cursor: pointer;
            background-color: #333; color: white; border: 1px solid #555;
            font-size: 0.8em; padding: 2px; border-radius: 3px;
            width: 50px;
        }
        #integrated-controls-panel input[type="datetime-local"] {
            background-color: #333; color: white; border: 1px solid #555;
            font-size: 0.8em; padding: 2px; border-radius: 3px;
        }
        button.control-button {
            background-color: rgba(51, 51, 51, 0.9); color: white;
            border: 1px solid #555; padding: 3px 8px; cursor: pointer;
            border-radius: 4px; font-size: 0.8em;
            transition: background-color: 0.2s; white-space: nowrap;
        }
        button.control-button:hover { background-color: rgba(85, 85, 85, 0.9); }
        button.control-button.active { background-color: rgba(0, 123, 255, 0.8); border-color: #007bff; }
        #chart-container {
            width: 95%; max-width: 1600px; height: 85vh;
            min-height: 350px;
            position: relative;
            margin: 10px auto 15px auto;
            cursor: crosshair;
        }
        #chart-context-menu {
            position: absolute; background-color: rgba(51, 51, 51, 0.95); color: white;
            padding: 5px 0; border-radius: 5px; border: 1px solid #666;
            z-index: 1000; display: none; min-width: 150px;
        }
        #chart-context-menu button {
            display: block; width: 100%; padding: 8px 15px; border: none;
            background-color: transparent; color: white; text-align: left;
            cursor: pointer; font-size: 0.9em;
        }
        #chart-context-menu button:hover { background-color: rgba(85, 85, 85, 0.9); }
    </style>
</head>
<body>

    <div id="integrated-controls-panel">
        <div class="ic-group">
            <span id="symbol">Symbol: BTCUSDT</span>
            <span id="timeframe-display">Timeframe: 1M</span>
            <span id="countdown">Countdown: 00:00</span>
        </div>
        <div class="ic-group" id="timeframe-buttons">
            <button class="control-button" data-timeframe="1m">1m</button>
            <button class="control-button" data-timeframe="5m">5m</button>
            <button class="control-button" data-timeframe="15m">15m</button>
            <button class="control-button" data-timeframe="1h">1h</button>
            <button class="control-button" data-timeframe="4h">4h</button>
            <button class="control-button" data-timeframe="1d">1d</button>
        </div>
        <div class="ic-group" id="analysis-tools">
            <button id="set-criterion-btn" class="control-button">Í∏∞Ï§ÄÏÑ† Î∂ÑÏÑù (C)</button>
            <button id="full-analysis-btn" class="control-button">Ï†ÑÏ≤¥ Î∂ÑÏÑù</button>
            <button id="auto-label-btn" class="control-button">ÏûêÎèô ÎùºÎ≤®ÎßÅ (P/T)</button>
             <button id="clear-shapes-btn" class="control-button">Ï†ÑÏ≤¥ ÏÇ≠Ï†ú</button>
            <label for="lookaround-input">ÎØºÍ∞êÎèÑ:</label>
            <input type="number" id="lookaround-input" value="10">
            <label for="tolerance-input">Ïù¥ÌÉà(%):</label>
            <input type="number" id="tolerance-input" value="0.05" step="0.01">
        </div>
        <div class="ic-group" id="drawing-controls">
             <button id="toggle-box-drawing-button" class="control-button">üì¶ Box On</button>
        </div>
        <div class="ic-group" id="view-controls">
            <label for="x-autorange-toggle-top">X Auto:</label>
            <input type="checkbox" id="x-autorange-toggle-top" style="width:auto;">
            <label for="y-autorange-toggle-top">Y Auto:</label>
            <input type="checkbox" id="y-autorange-toggle-top" checked style="width:auto;">
            <button id="zoom-in" class="control-button">T+</button>
            <button id="zoom-out" class="control-button">T-</button>
            <button id="zoom-price-up" class="control-button">P+</button>
            <button id="zoom-price-down" class="control-button">P-</button>
        </div>
        <div class="ic-group" id="time-travel-controls">
            <button id="calendar-icon-button" class="control-button" title="Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (ÏãúÍ∞Ñ Ïó¨Ìñâ)">üìÖ</button>
            <div id="time-travel-picker-area" style="display: none; align-items: center; gap: 5px;">
                <input type="datetime-local" id="datetime-picker">
                <button id="load-past-data-button" class="control-button">Î°úÎìú</button>
            </div>
            <button id="go-live-button" class="control-button" style="display: none;">Ïã§ÏãúÍ∞Ñ</button>
        </div>
    </div>


    <div id="chart-container">
        <div id="chart-context-menu">
            <button id="delete-box" style="display:none;">Delete Box</button>
        </div>
    </div>

    <script>
// ===================================================================================
// Ï†ÑÏó≠ Î≥ÄÏàò Î∞è Ï¥àÍ∏∞Ìôî
// ===================================================================================
const chartContainer = document.getElementById('chart-container');
const xAutoRangeToggle = document.getElementById('x-autorange-toggle-top');
const yAutoRangeToggle = document.getElementById('y-autorange-toggle-top');
const zoomInButton = document.getElementById('zoom-in');
const zoomOutButton = document.getElementById('zoom-out');
const zoomPriceUpButton = document.getElementById('zoom-price-up');
const zoomPriceDownButton = document.getElementById('zoom-price-down');
const contextMenu = document.getElementById('chart-context-menu');
const timeframeButtonsContainer = document.getElementById('timeframe-buttons');
const calendarIconButton = document.getElementById('calendar-icon-button');
const timeTravelPickerArea = document.getElementById('time-travel-picker-area');
const datetimePicker = document.getElementById('datetime-picker');
const loadPastDataButton = document.getElementById('load-past-data-button');
const goLiveButton = document.getElementById('go-live-button');
const toggleBoxDrawingButton = document.getElementById('toggle-box-drawing-button');
const deleteBoxButton = document.getElementById('delete-box');

let isBoxDrawingEnabled = false;
let drawnBoxes = [];
let currentBoxFirstPoint = null;
let contextMenuTargetInfo = null;
let isFullAnalysisDone = false;
let selectionBox = null;
let selectedSeries = [];
let klinesData = [];
let isXAutoRangeEnabled = false;
let isYAutoRangeEnabled = true;
let currentSymbol = "BTCUSDT";
let currentTimeframe = "1m";
let ws = null;
let nextCandleTime;
let candleIntervalMillis;
let countdownInterval = null;
let chartInitialized = false;
let fetchingMoreData = false;
let fetchingFutureData = false;
let isInTimeTravelMode = false;

const BOX_SHAPE_NAME_PREFIX = 'userDrawnBox_';
const MAX_DISPLAY_CANDLES = 1000;
const Y_AXIS_ZOOM_FACTOR = 0.05;
const X_AXIS_ZOOM_FACTOR = 0.10;
const PAN_FRACTION = 0.10;
const CANDLES_TO_FETCH_ON_PAN = 200;
const CANDLES_TO_FETCH_ON_PAN_RIGHT = 200;
const MAX_HISTORY = 3000;
const CROSSHAIR_LINE_STYLE = { color: 'grey', width: 0.5, dash: 'dash' };

function createDate(timestamp) { return new Date(timestamp); }
function getHiddenCrosshairShapes() { return [{ name: "crosshair_v", visible: false }, { name: "crosshair_h", visible: false }]; }

function calculateCandleIntervalMillis(tf) {
    if (tf.endsWith('m')) { return parseInt(tf.slice(0, -1)) * 60 * 1000; }
    else if (tf.endsWith('h')) { return parseInt(tf.slice(0, -1)) * 60 * 60 * 1000; }
    else if (tf.endsWith('d')) { return parseInt(tf.slice(0, -1)) * 24 * 60 * 60 * 1000; }
    return 60000;
}

function updateTopBar() {
    const timeframeDisplaySpan = document.getElementById('timeframe-display');
    const symbolSpan = document.getElementById('symbol');
    const countdownSpan = document.getElementById('countdown');
    if (timeframeDisplaySpan) timeframeDisplaySpan.textContent = `Timeframe: ${currentTimeframe.toUpperCase()}`;
    if (symbolSpan) symbolSpan.textContent = `Symbol: ${currentSymbol}`;
    if (isInTimeTravelMode) {
        if (countdownSpan) countdownSpan.textContent = "Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë";
        if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
        return;
    }
    const now = Date.now();
    let timeLeft = nextCandleTime - now;
    if (!nextCandleTime || timeLeft <= -500) {
        if (candleIntervalMillis) {
            const currentIntervalStart = Math.floor(now / candleIntervalMillis) * candleIntervalMillis;
            nextCandleTime = currentIntervalStart + candleIntervalMillis;
            timeLeft = nextCandleTime - now;
            if (timeLeft <= 0) { nextCandleTime += candleIntervalMillis; timeLeft = nextCandleTime - now; }
        } else { timeLeft = 0; }
    }
    const minutes = Math.floor(timeLeft / 60000);
    const seconds = Math.floor((timeLeft % 60000) / 1000);
    if (countdownSpan) countdownSpan.textContent = `Countdown: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    if (!countdownInterval && !isInTimeTravelMode) {
        countdownInterval = setInterval(updateTopBar, 1000);
    }
}

// ===================================================================================
// Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞ Î∞è ÏóÖÎç∞Ïù¥Ìä∏
// ===================================================================================
function initializePlotly(initialData = []) {
    const displayData = initialData;
    const traceCandle = {
        x: displayData.map(d => createDate(d[0])), open: displayData.map(d => Number(d[1])),
        high: displayData.map(d => Number(d[2])), low: displayData.map(d => Number(d[3])),
        close: displayData.map(d => Number(d[4])), type: 'candlestick', xaxis: 'x', yaxis: 'y',
        increasing: { line: { color: 'darkorange' } }, decreasing: { line: { color: 'royalblue' } }, name: 'Price'
    };

    const layout = {
        dragmode: 'pan',
        xaxis: { type: 'date', rangeslider: { visible: false }, fixedrange: false, tickformat: '%y/%m/%d %H:%M', color: '#A9A9A9', gridcolor: '#404040' },
        yaxis: { autorange: isYAutoRangeEnabled, fixedrange: false, color: '#A9A9A9', gridcolor: '#404040' },
        plot_bgcolor: '#1a1a1a', paper_bgcolor: 'black', font: { color: 'white' },
        margin: { t: 20, b: 40, l: 60, r: 60 }, hovermode: false, showlegend: false,
        shapes: [...getHiddenCrosshairShapes(), ...drawnBoxes],
        annotations: []
    };
    const config = { responsive: true, displayModeBar: false, scrollZoom: false };

    return Plotly.newPlot(chartContainer, [traceCandle], layout, config).then(() => {
        chartInitialized = true;
        setupChartEventListeners();
        handleDrawingToolToggle(isBoxDrawingEnabled ? 'box' : 'none');
    }).catch(err => {
        console.error("Error initializing Plotly:", err);
        chartInitialized = false;
        throw err;
    });
}

function updateChartRange(data, forceManualX = false, forceManualY = false) {
    if (!chartInitialized || !data || data.length === 0) return;
    const layoutUpdate = {};
    if (!isXAutoRangeEnabled || forceManualX) {
        const xValues = data.map(row => createDate(row[0]));
        if (xValues.length > 0) {
            const lastTime = xValues[xValues.length - 1].getTime();
            const paddingRight = candleIntervalMillis ? candleIntervalMillis * 10 : 600000;
            let defaultStartTime = xValues.length > MAX_DISPLAY_CANDLES ? xValues[xValues.length - MAX_DISPLAY_CANDLES].getTime() : xValues[0].getTime();
            layoutUpdate['xaxis.range'] = [createDate(defaultStartTime), createDate(lastTime + paddingRight)];
            layoutUpdate['xaxis.autorange'] = false;
        }
    } else {
        layoutUpdate['xaxis.autorange'] = true; layoutUpdate['xaxis.range'] = null;
    }

    if (!isYAutoRangeEnabled || forceManualY) {
        let yCalcData = data;
        if (chartContainer._fullLayout?.xaxis?.range) {
            const xRange = chartContainer._fullLayout.xaxis.range.map(d => new Date(d).getTime());
            yCalcData = data.filter(row => row[0] >= xRange[0] && row[0] <= xRange[1]);
        }
        if (yCalcData.length === 0 && data.length > 0) yCalcData = data.slice(-Math.min(data.length, MAX_DISPLAY_CANDLES));
        if (yCalcData.length > 0) {
            const minPrice = Math.min(...yCalcData.map(row => Number(row[3])));
            const maxPrice = Math.max(...yCalcData.map(row => Number(row[2])));
            if (isFinite(minPrice) && isFinite(maxPrice)) {
                const pricePadding = (maxPrice - minPrice) * 0.1 || (minPrice * 0.005 || 0.05);
                layoutUpdate['yaxis.range'] = [minPrice - pricePadding, maxPrice + pricePadding];
                layoutUpdate['yaxis.autorange'] = false;
            }
        }
    } else {
        layoutUpdate['yaxis.autorange'] = true; layoutUpdate['yaxis.range'] = null;
    }
    Plotly.relayout(chartContainer, layoutUpdate);
}

function updatePlotlyChart(data) {
    if (!chartInitialized || !data) return;
    const candleUpdate = {
        x: [data.map(row => createDate(row[0]))], open: [data.map(row => Number(row[1]))],
        high: [data.map(row => Number(row[2]))], low: [data.map(row => Number(row[3]))],
        close: [data.map(row => Number(row[4]))]
    };
    Plotly.update(chartContainer, candleUpdate, {}, [0]);
}

// ===================================================================================
// Îç∞Ïù¥ÌÑ∞ Î°úÎî© (API, WebSocket)
// ===================================================================================
async function fetchHistoricalData(symbol, timeframe) {
    try {
        const response = await fetch(`/api/klines?symbol=${symbol}&timeframe=${timeframe}&limit=${MAX_DISPLAY_CANDLES}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
            klinesData = data.map(k => [k[0], k[1], k[2], k[3], k[4], parseFloat(k[5] || 0)]).sort((a, b) => a[0] - b[0]);
            return true;
        }
        klinesData = []; return false;
    } catch (error) {
        console.error("Failed to fetch historical data:", error);
        klinesData = []; return false;
    }
}

async function fetchMoreHistoricalData() {
    if (fetchingMoreData || klinesData.length === 0) return;
    fetchingMoreData = true;
    try {
        const earliestTimeCurrent = klinesData[0][0];
        const response = await fetch(`/api/klines?symbol=${currentSymbol}&timeframe=${currentTimeframe}&limit=${CANDLES_TO_FETCH_ON_PAN}&before=${earliestTimeCurrent}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
            const newKlines = data.map(k => [k[0], k[1], k[2], k[3], k[4], parseFloat(k[5] || 0)]).sort((a, b) => a[0] - b[0]);
            klinesData = newKlines.concat(klinesData);
            if (klinesData.length > MAX_HISTORY) klinesData.splice(MAX_HISTORY);
            if (chartInitialized) updatePlotlyChart(klinesData);
        }
    } catch (error) { console.error("Failed to fetch more historical data:", error); }
    finally { fetchingMoreData = false; }
}

async function fetchFutureData(fetchStartTime, fetchEndTime) {
    if (fetchingFutureData || !fetchStartTime || !fetchEndTime || fetchStartTime >= fetchEndTime) return;
    if (!isInTimeTravelMode && fetchEndTime > Date.now() - (candleIntervalMillis || 60000)) return;
    fetchingFutureData = true;
    try {
        const response = await fetch(`/api/klines?symbol=${currentSymbol}&timeframe=${currentTimeframe}&startTime=${fetchStartTime}&endTime=${fetchEndTime}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
            const lastTimeInData = klinesData.length > 0 ? klinesData[klinesData.length - 1][0] : 0;
            const uniqueNewKlines = data.map(k => [k[0], k[1], k[2], k[3], k[4], parseFloat(k[5] || 0)]).filter(nk => nk[0] > lastTimeInData);
            if (uniqueNewKlines.length > 0) {
                klinesData = klinesData.concat(uniqueNewKlines);
                if (klinesData.length > MAX_HISTORY) klinesData.splice(0, klinesData.length - MAX_HISTORY);
                if (chartInitialized) {
                    updatePlotlyChart(klinesData);
                    if (isXAutoRangeEnabled) updateChartRange(klinesData);
                }
            }
        }
    } catch (error) { console.error("Failed to fetch future data:", error); }
    finally { fetchingFutureData = false; }
}

async function fetchAndDisplayTimeTravelData(selectedEndTime) {
    if (fetchingMoreData || fetchingFutureData) return;
    chartInitialized = false; fetchingMoreData = true;
    const calculatedStartTime = selectedEndTime - (MAX_DISPLAY_CANDLES * (candleIntervalMillis || 60000));
    chartContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...</div>';
    if (ws) { ws.close(); ws = null; }
    if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
    isInTimeTravelMode = true; updateTopBar();
    try {
        const response = await fetch(`/api/klines?symbol=${currentSymbol}&timeframe=${currentTimeframe}&startTime=${calculatedStartTime}&endTime=${selectedEndTime}&limit=${MAX_DISPLAY_CANDLES}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
            klinesData = data.map(k => [k[0], k[1], k[2], k[3], k[4], parseFloat(k[5] || 0)]).sort((a, b) => a[0] - b[0]);
            drawnBoxes = [];
            if (chartContainer._fullLayout) Plotly.purge(chartContainer);
            
            await initializePlotly(klinesData);
            updateChartRange(klinesData, true, false);

            timeTravelPickerArea.style.display = 'none'; goLiveButton.style.display = 'inline-block'; calendarIconButton.classList.add('active');
        } else {
            chartContainer.innerHTML = `<p style="color:red; padding: 20px;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®.</p>`;
        }
    } catch (error) {
        console.error("ÏãúÍ∞Ñ Ïó¨Ìñâ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë Ïò§Î•ò:", error);
    } finally { fetchingMoreData = false; }
}

function connectWebSocket(symbol, timeframe) {
    if (isInTimeTravelMode) { if (ws) { ws.close(); ws = null; } return; }
    if (ws) { ws.close(); ws = null; }
    const wsSymbol = symbol.toLowerCase();
    const websocketURL = `wss://stream.binance.com:9443/ws/${wsSymbol}@kline_${timeframe}`;
    ws = new WebSocket(websocketURL);

    ws.onopen = () => {
        console.log('WebSocket connected');
        if (klinesData.length > 0) { nextCandleTime = klinesData[klinesData.length - 1][0] + candleIntervalMillis; }
        updateTopBar();
    };

    ws.onmessage = (event) => {
        if (!chartInitialized) return;
        try {
            const k = JSON.parse(event.data).k;
            const newKline = [parseInt(k.t), parseFloat(k.o), parseFloat(k.h), parseFloat(k.l), parseFloat(k.c), parseFloat(k.v) || 0];
            if (klinesData.length === 0) { klinesData.push(newKline); }
            else {
                const lastKlineTime = klinesData[klinesData.length - 1][0];
                if (newKline[0] === lastKlineTime) { klinesData[klinesData.length - 1] = newKline; }
                else if (newKline[0] > lastKlineTime) {
                    klinesData.push(newKline);
                    if (klinesData.length > MAX_HISTORY) klinesData.shift();
                    nextCandleTime = newKline[0] + candleIntervalMillis;
                }
            }
            updatePlotlyChart(klinesData);
            if (isXAutoRangeEnabled || isYAutoRangeEnabled) updateChartRange(klinesData);
        } catch (error) { console.error("WS Error:", error); }
    };

    ws.onclose = () => { console.log('WS disconnected.'); ws = null; };
    ws.onerror = (err) => { console.error('WS error:', err); ws = null; };
}

// ===================================================================================
// Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî Î∞è Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
// ===================================================================================
async function initializeCharts(symbol, timeframe) {
    chartInitialized = false; isInTimeTravelMode = false;
    calendarIconButton.classList.remove('active');
    goLiveButton.style.display = 'none';
    timeTravelPickerArea.style.display = 'none';
    drawnBoxes = []; currentBoxFirstPoint = null;
    isBoxDrawingEnabled = false; handleDrawingToolToggle('none');

    if (chartContainer._fullLayout) Plotly.purge(chartContainer);
    chartContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...</div>';
    candleIntervalMillis = calculateCandleIntervalMillis(timeframe);
    if (countdownInterval) clearInterval(countdownInterval);
    if (ws) ws.close();
    const historicalDataLoaded = await fetchHistoricalData(symbol, timeframe);
    if (!historicalDataLoaded) {
        chartContainer.innerHTML = `<p style="color:red; padding: 20px;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®.</p>`;
        return;
    }
    
    await initializePlotly(klinesData);
    updateChartRange(klinesData);

    updateTopBar();
    connectWebSocket(symbol, timeframe);
    updateActiveTimeframeButton(timeframe);
}

function setupChartEventListeners() {
    document.removeEventListener('keydown', handleKeyDown);
    chartContainer.removeEventListener('wheel', handleWheelZoom);
    chartContainer.removeEventListener('click', handleChartClick);
    chartContainer.removeEventListener('contextmenu', handleContextMenu);
    chartContainer.removeEventListener('mousemove', handleMouseMove);
    chartContainer.removeEventListener('mouseleave', handleMouseLeave);
    if (chartContainer.off) chartContainer.off('plotly_relayout', handleRelayout);

    document.addEventListener('keydown', handleKeyDown);
    chartContainer.addEventListener('wheel', handleWheelZoom, { passive: false });
    chartContainer.addEventListener('click', handleChartClick);
    chartContainer.addEventListener('contextmenu', handleContextMenu);
    chartContainer.addEventListener('mousemove', handleMouseMove);
    chartContainer.addEventListener('mouseleave', handleMouseLeave);
    if (chartContainer.on) chartContainer.on('plotly_relayout', handleRelayout);

    zoomInButton.addEventListener('click', () => zoomTime(true));
    zoomOutButton.addEventListener('click', () => zoomTime(false));
    zoomPriceUpButton.addEventListener('click', () => adjustPriceScale(true));
    zoomPriceDownButton.addEventListener('click', () => adjustPriceScale(false));
    toggleBoxDrawingButton.addEventListener('click', () => handleDrawingToolToggle('box'));
    deleteBoxButton.addEventListener('click', handleDeleteBox);
    xAutoRangeToggle.addEventListener('change', handleXAutoRangeToggle);
    yAutoRangeToggle.addEventListener('change', handleYAutoRangeToggle);
    calendarIconButton.addEventListener('click', handleCalendarIconClick);
    loadPastDataButton.addEventListener('click', handleLoadPastDataClick);
    goLiveButton.addEventListener('click', () => initializeCharts(currentSymbol, currentTimeframe));

    document.getElementById("set-criterion-btn").addEventListener("click", triggerAnalysisAtCenter);
    document.getElementById("clear-shapes-btn").addEventListener("click", clearAllShapes);
    document.getElementById("auto-label-btn").addEventListener("click", performAutoLabeling);
    document.getElementById("full-analysis-btn").addEventListener("click", analyzeEntireChart);
}

// ===================================================================================
// üí• ÏµúÏ¢Ö ÌïòÏù¥Î∏åÎ¶¨Îìú Î∂ÑÏÑù ÏóîÏßÑ (2025-08-01 Î≤ÑÏ†Ñ)
// ===================================================================================

/**
 * üí• [Î©îÏù∏] Ï†ÑÏ≤¥ Ï∞®Ìä∏Î•º Î∂ÑÏÑùÌïòÏó¨ Î©îÏù∏/ÏÑúÎ∏å ÏãúÎ¶¨Ï¶àÎ•º Î™®Îëê ÏãùÎ≥ÑÌïòÍ≥† ÌÖêÏÑúÎ°ú Î≥ÄÌôòÌïúÎã§.
 */
function analyzeEntireChart() {
    if (!chartInitialized) return;
    clearAllShapes();
    console.log("ÌïòÏù¥Î∏åÎ¶¨Îìú Î∂ÑÏÑù ÏóîÏßÑ Í∞ÄÎèô...");

    // --- 1. Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ ---
    const lookaround = parseInt(document.getElementById('lookaround-input').value, 10);
    if (isNaN(lookaround)) { console.error("Lookaround Í∞íÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§."); return; }
    const { allPivots: rawPivots } = findPivots(0, klinesData, lookaround);
    const allPivots = consolidatePivots(rawPivots);
    if (allPivots.length < 2) { console.log("Î∂ÑÏÑùÌï† ÌîºÎ¥áÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§."); return; }
    const toleranceFactors = {
        lower: 1 - ((parseFloat(document.getElementById('tolerance-input').value) || 0) / 100),
        upper: 1 + ((parseFloat(document.getElementById('tolerance-input').value) || 0) / 100)
    };

    // --- 2. Î©îÏù∏ ÏãúÎ¶¨Ï¶à ÏãùÎ≥Ñ (Í∏∞Ï°¥ Î°úÏßÅ ÌôúÏö©) ---
    const mainSeriesShapes = findMainSeries(allPivots, toleranceFactors);

    // --- 3. Î™®Îì† ÏãúÎ¶¨Ï¶à(Î©îÏù∏/ÏÑúÎ∏å)Î•º Ìè¨Ìï®ÌïòÎäî ÌÜµÌï© ÏãúÌÄÄÏä§ ÏÉùÏÑ± ---
    const consolidatedSeries = [];
    let lastProcessedPivotIndex = -1;

    // Î©îÏù∏ ÏãúÎ¶¨Ï¶àÏôÄ Í∑∏ ÏÇ¨Ïù¥Ïùò Í∞≠ÏùÑ Ï≤òÎ¶¨
    for (let i = 0; i < mainSeriesShapes.length; i++) {
        const mainSeries = mainSeriesShapes[i];
        
        // --- 3a. Ïù¥Ï†Ñ Î©îÏù∏ ÏãúÎ¶¨Ï¶àÏùò ÎÅù ~ ÌòÑÏû¨ Î©îÏù∏ ÏãúÎ¶¨Ï¶àÏùò ÏãúÏûëÍπåÏßÄ Í∞≠ Ï≤òÎ¶¨ ---
        const mainSeriesStartIndex = allPivots.findIndex(p => p.time === new Date(mainSeries.x0).getTime());
        if (mainSeriesStartIndex > lastProcessedPivotIndex + 1) {
            const gapPivots = allPivots.slice(lastProcessedPivotIndex + 1, mainSeriesStartIndex + 1);
            for (let j = 0; j < gapPivots.length - 1; j++) {
                consolidatedSeries.push(createSeriesShape(gapPivots[j], gapPivots[j + 1], 'SUB'));
            }
        }
        
        // --- 3b. Î©îÏù∏ ÏãúÎ¶¨Ï¶à Ï∂îÍ∞Ä ---
        consolidatedSeries.push(mainSeries);
        lastProcessedPivotIndex = allPivots.findIndex(p => p.time === new Date(mainSeries.x1).getTime());
    }

    // --- 3c. ÎßàÏßÄÎßâ Î©îÏù∏ ÏãúÎ¶¨Ï¶à Ïù¥ÌõÑÏùò ÌîºÎ¥áÎì§ÏùÑ ÏÑúÎ∏å ÏãúÎ¶¨Ï¶àÎ°ú Ï≤òÎ¶¨ ---
    if (lastProcessedPivotIndex < allPivots.length - 1) {
        const remainingPivots = allPivots.slice(lastProcessedPivotIndex + 1);
        for (let i = 0; i < remainingPivots.length - 1; i++) {
            consolidatedSeries.push(createSeriesShape(remainingPivots[i], remainingPivots[i + 1], 'SUB'));
        }
    }

    // --- 4. ÏµúÏ¢Ö Î∂ÑÏÑù Î∞è ÏãúÍ∞ÅÌôî ---
    analyzeAndVectorizeAllSeries(consolidatedSeries, allPivots);
    const shapesToDraw = consolidatedSeries.map(s => s.shape);
    drawAnalysisResults({ shapes: shapesToDraw, annotations: [] });

    isFullAnalysisDone = true;
    toggleBoxDrawingButton.textContent = 'üíé ÏãúÎ¶¨Ï¶à ÏÑ†ÌÉù';
}


/**
 * [HELPER] `analyzeEntireChart`Ïùò ÏùºÎ∂ÄÎ°ú, Î©îÏù∏ ÏãúÎ¶¨Ï¶àÎßå Ï∞æÏïÑÎÇ¥Îäî Ìï®Ïàò.
 */
function findMainSeries(allPivots, toleranceFactors) {
    const mainSeriesShapes = [];
    const allTroughs = allPivots.filter(p => p.type === 'T');
    const allPeaks = allPivots.filter(p => p.type === 'P');
    let searchFromTime = klinesData.length > 0 ? klinesData[0][0] : 0;
    const endTime = klinesData.length > 0 ? klinesData[klinesData.length - 1][0] : 0;

    while (searchFromTime < endTime) {
        let nextPattern = { startTime: Infinity, type: null };
        for (let i = 0; i < allTroughs.length - 1; i++) {
            if (allTroughs[i].time >= searchFromTime && allTroughs[i + 1].price > allTroughs[i].price) {
                nextPattern = { startTime: allTroughs[i].time, type: 'up' };
                break;
            }
        }
        for (let i = 0; i < allPeaks.length - 1; i++) {
            if (allPeaks[i].time >= searchFromTime && allPeaks[i + 1].price < allPeaks[i].price) {
                if (allPeaks[i].time < nextPattern.startTime) {
                    nextPattern = { startTime: allPeaks[i].time, type: 'down' };
                }
                break;
            }
        }

        if (nextPattern.type === null) break;

        const pivotContext = allPivots.filter(p => p.time >= nextPattern.startTime).slice(0, 20);
        let yellowLine = null;

        if (nextPattern.type === 'up') {
            const analysisResult = analyzeUpwardChannel(pivotContext, allPivots, klinesData, toleranceFactors);
            yellowLine = analysisResult.shapes.find(s => s.name === 'analysis_connecting_line_up');
        } else if (nextPattern.type === 'down') {
            const analysisResult = analyzeDownwardChannel(pivotContext, allPivots, klinesData, toleranceFactors);
            yellowLine = analysisResult.shapes.find(s => s.name === 'analysis_connecting_line_down');
        }

        if (yellowLine) {
            const seriesType = yellowLine.name.includes('up') ? 'MAIN_UP' : 'MAIN_DOWN';
            mainSeriesShapes.push({
                type: seriesType,
                shape: { ...yellowLine, line: { color: 'rgba(255, 255, 0, 0.6)', width: 2.5, dash: 'solid' } }
            });
            searchFromTime = new Date(yellowLine.x1).getTime();
        } else {
            searchFromTime = nextPattern.startTime + (candleIntervalMillis || 300000);
        }
    }
    return mainSeriesShapes.sort((a,b) => new Date(a.shape.x0).getTime() - new Date(b.shape.x0).getTime());
}

/**
 * [HELPER] Îëê ÌîºÎ¥áÏùÑ Î∞õÏïÑ ÏÑúÎ∏å ÏãúÎ¶¨Ï¶à Í∞ùÏ≤¥Î•º ÏÉùÏÑ±ÌïúÎã§.
 */
function createSeriesShape(p1, p2, typePrefix) {
    const isUp = p2.price > p1.price;
    const seriesType = `${typePrefix}_${isUp ? 'UP' : 'DOWN'}`;
    return {
        type: seriesType,
        shape: {
            name: `series_${p1.time}_${p2.time}`,
            type: 'line', layer: 'below', xref: 'x', yref: 'y',
            x0: createDate(p1.time), y0: p1.price,
            x1: createDate(p2.time), y1: p2.price,
            line: { color: isUp ? 'rgba(0, 150, 255, 0.7)' : 'rgba(255, 140, 0, 0.7)', width: 1.5, dash: 'dash' }
        }
    };
}


/**
 * üí• [ÎßàÏä§ÌÑ∞ Î∂ÑÏÑù] Î™®Îì† ÏãúÎ¶¨Ï¶à(Î©îÏù∏/ÏÑúÎ∏å)Ïùò ÏãúÌÄÄÏä§Î•º Î∞õÏïÑ Î∂ÑÏÑùÌïòÍ≥† ÌÖêÏÑúÌôîÌïúÎã§.
 */
function analyzeAndVectorizeAllSeries(seriesSequence, allPivots) {
    if (!seriesSequence || seriesSequence.length === 0) {
        console.log("Î∂ÑÏÑùÌï† ÏãúÎ¶¨Ï¶à ÏãúÌÄÄÏä§Í∞Ä ÏóÜÏäµÎãàÎã§.");
        return;
    }

    let previousSeriesFeatures = null;
    const analysisResults = [];
    const finalTensors = [];

    for (const series of seriesSequence) {
        const features = extractSeriesFeatures(series, allPivots);
        if (!features) continue;

        const tensor = calculateTensor(features, previousSeriesFeatures);

        analysisResults.push(features);
        finalTensors.push(tensor);
        previousSeriesFeatures = features; // Îã§Ïùå Î£®ÌîÑÎ•º ÏúÑÌï¥ ÌòÑÏû¨ ÏãúÎ¶¨Ï¶àÎ•º Ïù¥Ï†Ñ ÏãúÎ¶¨Ï¶àÎ°ú Ï†ÄÏû•
    }

    // --- ÏµúÏ¢Ö Í≤∞Í≥º Ï∂úÎ†• ---
    console.clear();
    console.log(`%c--- üî• ÌïòÏù¥Î∏åÎ¶¨Îìú ÏãúÎ¶¨Ï¶à Î∂ÑÏÑù Í≤∞Í≥º (${analysisResults.length}Í∞ú) üî• ---`, "color: yellow; font-size: 1.2em; font-weight: bold;");
    console.log(`%c[üìä ÏãúÎ¶¨Ï¶à ÏÉÅÏÑ∏ Ï†ïÎ≥¥]`, "color: cyan; font-weight: bold;");
    console.table(analysisResults.map(r => ({
        series_id: r.series_id, series_type: r.series_type,
        start_time: new Date(r.start_time_timestamp).toLocaleString(),
        end_time: new Date(r.end_time_timestamp).toLocaleString(),
        slope: r.slope, total_volume: r.total_volume, pivot_count: r.pivot_count
    })));

    console.log(`%c[üí• ÏµúÏ¢Ö ÌÖêÏÑú ÏãúÌÄÄÏä§ (${finalTensors.length} x 141Ï∞®Ïõê)]`, "color: tomato; font-weight: bold; font-size: 1.1em");
    console.log(finalTensors);
}

/**
 * üí• [ÌäπÏÑ± Ï∂îÏ∂ú] Îã®Ïùº ÏãúÎ¶¨Ï¶à(Î©îÏù∏/ÏÑúÎ∏å)Ïùò ÌäπÏÑ±ÏùÑ Ï∂îÏ∂úÌïòÏó¨ Í∞ùÏ≤¥Î°ú Î∞òÌôòÌïúÎã§.
 */
function extractSeriesFeatures(seriesObject, allPivots) {
    const { shape, type } = seriesObject;
    const startTimeMs = new Date(shape.x0).getTime();
    const endTimeMs = new Date(shape.x1).getTime();
    const seriesKlines = klinesData.filter(k => k[0] >= startTimeMs && k[0] <= endTimeMs);
    const internalPivots = allPivots.filter(p => p.time > startTimeMs && p.time < endTimeMs);

    const totalVolume = seriesKlines.reduce((sum, k) => sum + (k[5] || 0), 0);
    const durationSec = (endTimeMs - startTimeMs) / 1000;
    const slope = durationSec > 0 ? (shape.y1 - shape.y0) / durationSec : 0;
    const swing = shape.y1 - shape.y0;

    return {
        series_id: shape.name, series_type: type,
        start_time_timestamp: startTimeMs, end_time_timestamp: endTimeMs,
        start_price: shape.y0, end_price: shape.y1,
        slope: slope.toExponential(2), total_volume: totalVolume.toFixed(2),
        duration_sec: durationSec, swing: swing,
        pivot_count: internalPivots.length + 2,
        internal_pivots: internalPivots, // ÌÖêÏÑú Í≥ÑÏÇ∞ Ïãú ÌïÑÏöî
    };
}


/**
 * üí• [ÌÖêÏÑú Í≥ÑÏÇ∞] Îã®Ïùº ÏãúÎ¶¨Ï¶àÏùò ÌäπÏÑ± Í∞ùÏ≤¥Î•º Î∞õÏïÑ ÏµúÏ¢Ö 141Ï∞®Ïõê ÌÖêÏÑúÎ•º Í≥ÑÏÇ∞ÌïúÎã§.
 */
function calculateTensor(features, prevFeatures) {
    const vector = new Array(141).fill(0);

    // --- 1. ÌÉÄÏûÖ ÏõêÌï´ Ïù∏ÏΩîÎî© (2Ï∞®Ïõê) ---
    vector[0] = features.series_type.includes('UP') ? 1 : 0;
    vector[1] = features.series_type.includes('DOWN') ? 1 : 0;

    // --- 2. Í≥µÌÜµ ÌäπÏÑ± (4Ï∞®Ïõê) ---
    vector[2] = parseFloat(features.duration_sec);
    vector[3] = parseFloat(features.slope);
    vector[4] = parseFloat(features.total_volume);
    vector[5] = parseFloat(features.pivot_count);

    // --- 3. ÎêòÎèåÎ¶º DNA Í≥ÑÏÇ∞ (135Ï∞®Ïõê) ---
    const retraceVector = calculateRetracementVector(features, prevFeatures);
    for (let i = 0; i < retraceVector.length; i++) {
        vector[6 + i] = retraceVector[i];
    }
    
    return vector.map(v => parseFloat(v.toFixed(6)));
}

/**
 * üí• [ÎêòÎèåÎ¶º Í≥ÑÏÇ∞] ÏãúÎ¶¨Ï¶à ÌÉÄÏûÖÏóê Îî∞Îùº ÎêòÎèåÎ¶º Î≤°ÌÑ∞(135Ï∞®Ïõê)Î•º Í≥ÑÏÇ∞ÌïòÎäî ÌïµÏã¨ Î°úÏßÅ.
 */
function calculateRetracementVector(features, prevFeatures) {
    const vector = new Array(135).fill(0);
    const MAX_SEQUENCES_TO_ENCODE = 15;
    const NUM_CATEGORIES = 9;

    if (features.series_type.startsWith('MAIN')) {
        // [MAIN ÏãúÎ¶¨Ï¶à Î°úÏßÅ] ÎÇ¥Î∂Ä ÎêòÎèåÎ¶º Í≥ÑÏÇ∞
        const internalPivotsWithEnds = [
            { time: features.start_time_timestamp, price: features.start_price, type: features.series_type.includes('UP') ? 'T' : 'P' },
            ...features.internal_pivots,
            { time: features.end_time_timestamp, price: features.end_price, type: features.series_type.includes('UP') ? 'P' : 'T' }
        ];

        let sequenceCount = 0;
        if (internalPivotsWithEnds.length >= 3) {
            for (let i = 2; i < internalPivotsWithEnds.length && sequenceCount < MAX_SEQUENCES_TO_ENCODE; i++) {
                const p0 = internalPivotsWithEnds[i - 2], p1 = internalPivotsWithEnds[i - 1], p2 = internalPivotsWithEnds[i];
                if (p0.type !== p1.type && p1.type !== p2.type) {
                    let swing_range = 0, retracement_amount = 0;
                    if (p0.type === 'T') { // T-P-T
                        swing_range = p1.price - p0.price; retracement_amount = p1.price - p2.price;
                    } else { // P-T-P
                        swing_range = p0.price - p1.price; retracement_amount = p2.price - p1.price;
                    }

                    if (swing_range > 0) {
                        const ratio = retracement_amount / swing_range;
                        const oneHot = getOneHotVectorForRatio(ratio, NUM_CATEGORIES);
                        oneHot.forEach((val, idx) => {
                            vector[sequenceCount * NUM_CATEGORIES + idx] = val;
                        });
                        sequenceCount++;
                    }
                }
            }
        }
    } else if (features.series_type.startsWith('SUB')) {
        // [SUB ÏãúÎ¶¨Ï¶à Î°úÏßÅ] Ïô∏Î∂Ä ÎêòÎèåÎ¶º Í≥ÑÏÇ∞
        if (prevFeatures && prevFeatures.swing !== 0) {
            const ratio = Math.abs(features.swing) / Math.abs(prevFeatures.swing);
            const oneHot = getOneHotVectorForRatio(ratio, NUM_CATEGORIES);
            oneHot.forEach((val, idx) => {
                vector[idx] = val; // 135Ïπ∏ Ï§ë Îß® ÏïûÏóêÎßå Ï±ÑÏõÄ
            });
        }
    }
    return vector;
}

/**
 * [HELPER] ÎêòÎèåÎ¶º ÎπÑÏú®ÏùÑ Î∞õÏïÑ 9Í∞ú Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò ÏõêÌï´ Î≤°ÌÑ∞Î•º Î∞òÌôòÌïúÎã§.
 */
function getOneHotVectorForRatio(ratio, numCategories) {
    const oneHotVector = new Array(numCategories).fill(0);
    const absRatioPercent = Math.abs(ratio * 100);
    let categoryIndex = -1;
    if (absRatioPercent < 35.5) categoryIndex = 0;
    else if (absRatioPercent < 58.5) categoryIndex = 1;
    else if (absRatioPercent < 74.5) categoryIndex = 2;
    else if (absRatioPercent < 91) categoryIndex = 3;
    else if (absRatioPercent < 100) categoryIndex = 4;
    else if (absRatioPercent < 125) categoryIndex = 5;
    else if (absRatioPercent < 200) categoryIndex = 6;
    else if (absRatioPercent <= 300) categoryIndex = 7;
    else categoryIndex = 8;
    if (categoryIndex !== -1) { oneHotVector[categoryIndex] = 1; }
    return oneHotVector;
}

// ===================================================================================
// Í∏∞Ï°¥ Î∂ÑÏÑù Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò (Ï±ÑÎÑê Î∂ÑÏÑù Îì±)
// ===================================================================================
function triggerAnalysis(timestamp) {
    clearAnalysisShapes();
    const lookaround = parseInt(document.getElementById('lookaround-input').value, 10);
    const tolerancePercent = parseFloat(document.getElementById('tolerance-input').value) || 0;
    const toleranceFactors = { lower: 1 - (tolerancePercent / 100), upper: 1 + (tolerancePercent / 100) };
    if (isNaN(lookaround) || lookaround < 1) return;

    const { allPivots, closestPivots } = findPivots(timestamp, klinesData, lookaround);
    let shapes = [{ name: 'analysis_vline', type: 'line', xref: 'x', yref: 'paper', x0: createDate(timestamp), x1: createDate(timestamp), y0: 0, y1: 1, line: { color: 'rgba(255, 255, 255, 0.4)', width: 1, dash: 'longdash' } }];
    let annotations = [];

    if (closestPivots && closestPivots.length > 0) {
        const analysisResult = analyzeChannelAndConnections(closestPivots, allPivots, klinesData, toleranceFactors);
        shapes.push(...analysisResult.shapes);
        annotations.push(...analysisResult.annotations);
    }
    drawAnalysisResults({ shapes, annotations });
}

function drawAnalysisResults({ shapes, annotations }) {
    const existingAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => !a.name?.startsWith('analysis_') && !a.name?.startsWith('auto_'));
    Plotly.relayout(chartContainer, {
        shapes: [...getHiddenCrosshairShapes(), ...drawnBoxes, ...shapes],
        annotations: [...existingAnnotations, ...annotations]
    });
}

function clearAnalysisShapes() {
    const nonAnalysisShapes = (chartContainer._fullLayout.shapes || []).filter(s => !s.name?.startsWith('analysis_'));
    const nonAnalysisAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => !a.name?.startsWith('analysis_'));
    Plotly.relayout(chartContainer, { shapes: nonAnalysisShapes, annotations: nonAnalysisAnnotations });
}

function clearAllShapes() {
    drawnBoxes = []; currentBoxFirstPoint = null; selectionBox = null;
    selectedSeries = []; isFullAnalysisDone = false;
    toggleBoxDrawingButton.textContent = 'üì¶ Box On';
    Plotly.relayout(chartContainer, { shapes: getHiddenCrosshairShapes(), annotations: [] });
}

function findPivots(timestamp, data, lookaround) {
    const allPivots = [];
    for (let i = lookaround; i < data.length - lookaround; i++) {
        const windowData = data.slice(i - lookaround, i + lookaround + 1);
        const currentCandle = data[i];
        if (currentCandle[2] >= Math.max(...windowData.map(d => d[2]))) {
            allPivots.push({ time: currentCandle[0], price: currentCandle[2], type: 'P', distance: Math.abs(currentCandle[0] - timestamp) });
        }
        if (currentCandle[3] <= Math.min(...windowData.map(d => d[3]))) {
            allPivots.push({ time: currentCandle[0], price: currentCandle[3], type: 'T', distance: Math.abs(currentCandle[0] - timestamp) });
        }
    }
    if (timestamp === 0) {
        allPivots.sort((a, b) => a.time - b.time);
        return { allPivots };
    }
    const pivotsOnRight = allPivots.filter(pivot => pivot.time > timestamp).sort((a, b) => a.distance - b.distance);
    return { allPivots, closestPivots: pivotsOnRight.slice(0, 20) };
}

function consolidatePivots(pivots) {
    if (!pivots || pivots.length === 0) return [];
    const consolidated = []; let i = 0;
    while (i < pivots.length) {
        const currentPivot = pivots[i], group = [currentPivot]; let j = i + 1;
        while (j < pivots.length && pivots[j].type === currentPivot.type) { group.push(pivots[j]); j++; }
        if (group.length > 1) {
            if (currentPivot.type === 'P') { consolidated.push(group.reduce((max, p) => p.price > max.price ? p : max, group[0])); }
            else { consolidated.push(group.reduce((min, p) => p.price < min.price ? p : min, group[0])); }
            i = j;
        } else { consolidated.push(currentPivot); i++; }
    }
    return consolidated;
}

function analyzeChannelAndConnections(closestPivots, allPivots, klinesData, toleranceFactors) {
    const initialShapes = [], initialAnnotations = [];
    const pivotsSortedByTime = [...closestPivots].sort((a, b) => a.time - b.time);
    pivotsSortedByTime.forEach((pivot, index) => {
        initialAnnotations.push({ name: `analysis_label_${index}`, x: createDate(pivot.time), y: pivot.price, text: pivot.type, showarrow: true, arrowhead: 4, ax: 0, ay: pivot.type === 'P' ? -25 : 25, bgcolor: pivot.type === 'P' ? 'rgba(255,100,0,0.7)' : 'rgba(0,100,255,0.7)', font: { color: 'white' } });
        if (index > 0) {
            const startPivot = pivotsSortedByTime[index - 1];
            initialShapes.push({ name: `analysis_zigzag_${index - 1}`, type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(startPivot.time), y0: startPivot.price, x1: createDate(pivot.time), y1: pivot.price, line: { color: 'rgba(255, 255, 255, 0.5)', width: 1, dash: 'dash' } });
        }
    });
    const upTrendResult = analyzeUpwardChannel(closestPivots, allPivots, klinesData, toleranceFactors);
    const downTrendResult = analyzeDownwardChannel(closestPivots, allPivots, klinesData, toleranceFactors);
    return { shapes: [...initialShapes, ...upTrendResult.shapes, ...downTrendResult.shapes], annotations: [...initialAnnotations, ...upTrendResult.annotations, ...downTrendResult.annotations] };
}

function analyzeUpwardChannel(closestPivots, allPivots, klinesData, toleranceFactors) {
    const shapes = [], annotations = [];
    const troughs = closestPivots.filter(p => p.type === 'T').sort((a, b) => a.time - b.time);
    if (troughs.length < 2) return { shapes, annotations };
    const t1 = troughs[0], t2 = troughs[1];
    if (t2.price < t1.price) {
        annotations.push({ name: 'analysis_label_uptrend_end_pre', x: createDate(t2.time), y: t2.price, text: '<b>ÏÉÅÏäπ Ï∂îÏÑ∏ Ï¢ÖÎ£å (T < T-1)</b>', showarrow: true, arrowhead: 7, ax: 0, ay: 40, bgcolor: 'darkred', bordercolor: 'white', borderwidth: 1, font: { color: 'white', size: 12 } });
        return { shapes, annotations };
    }
    const slope = (t2.price - t1.price) / (t2.time - t1.time);
    if (t2.time === t1.time) return { shapes, annotations };
    const xRange = chartContainer._fullLayout.xaxis.range, xStartTimestamp = new Date(xRange[0]).getTime(), xEndTimestamp = new Date(xRange[1]).getTime() + (24 * 60 * 60 * 1000);
    shapes.push({ name: 'analysis_trendline_up', type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(xStartTimestamp), y0: slope * (xStartTimestamp - t1.time) + t1.price, x1: createDate(xEndTimestamp), y1: slope * (xEndTimestamp - t1.time) + t1.price, line: { color: 'cyan', width: 1.5, dash: 'dot' } });
    const firstP = closestPivots.filter(p => p.type === 'P').sort((a, b) => a.time - b.time)[0];
    const breakthroughP = allPivots.filter(p => p.type === 'P' && p.time > firstP?.time && p.price > firstP?.price).sort((a, b) => a.time - b.time)[0];
    if (!breakthroughP) return { shapes, annotations };
    annotations.push({ name: `analysis_label_p_minus`, x: createDate(breakthroughP.time), y: breakthroughP.price, text: 'P-', showarrow: true, arrowhead: 4, ax: 0, ay: -35, bgcolor: 'rgba(255, 20, 147, 0.9)', font: { color: 'white', size: 14 } });
    shapes.push({ name: 'analysis_parallel_line_up', type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(xStartTimestamp), y0: slope * (xStartTimestamp - breakthroughP.time) + breakthroughP.price, x1: createDate(xEndTimestamp), y1: slope * (xEndTimestamp - breakthroughP.time) + breakthroughP.price, line: { color: 'cyan', width: 1.5, dash: 'dot' } });
    let lowerBreakoutCandle = null, upperBreakoutCandle = null;
    const startIndex = klinesData.findIndex(k => k[0] > t2.time);
    if (startIndex !== -1) {
        for (let i = startIndex; i < klinesData.length; i++) {
            const candle = klinesData[i], candleTime = candle[0], candleHigh = candle[2], candleLow = candle[3];
            if (!lowerBreakoutCandle) {
                const lowerBoundary = slope * (candleTime - t1.time) + t1.price;
                if (candleLow < (lowerBoundary * toleranceFactors.lower)) lowerBreakoutCandle = candle;
            }
            if (!upperBreakoutCandle && candleTime > breakthroughP.time) {
                const upperBoundary = slope * (candleTime - breakthroughP.time) + breakthroughP.price;
                if (candleHigh > (upperBoundary * toleranceFactors.upper)) upperBreakoutCandle = candle;
            }
            if (lowerBreakoutCandle && (upperBreakoutCandle || candleTime <= breakthroughP.time)) break;
            if (lowerBreakoutCandle && upperBreakoutCandle) break;
        }
    }
    if (lowerBreakoutCandle) annotations.push({ name: 'analysis_label_break_down_upchannel', x: createDate(lowerBreakoutCandle[0]), y: lowerBreakoutCandle[3], text: '<b>ÌïòÎã® Ïù¥ÌÉà</b>', showarrow: true, arrowhead: 7, ax: 0, ay: 40, bgcolor: 'rgba(255, 140, 0, 0.8)', bordercolor: 'white', borderwidth: 1, font: { color: 'white', size: 12 } });
    if (upperBreakoutCandle) annotations.push({ name: 'analysis_label_break_up_upchannel', x: createDate(upperBreakoutCandle[0]), y: upperBreakoutCandle[2], text: '<b>ÏÉÅÎã® ÎèåÌåå</b>', showarrow: true, arrowhead: 7, ax: 0, ay: -40, bgcolor: 'rgba(0, 150, 255, 0.8)', bordercolor: 'white', borderwidth: 1, font: { color: 'white', size: 12 } });
    const firstBreakoutTime = [lowerBreakoutCandle, upperBreakoutCandle].filter(Boolean).reduce((min, c) => Math.min(min, c[0]), Infinity);
    const channelEndTime = (firstBreakoutTime === Infinity) ? klinesData[klinesData.length - 1][0] : firstBreakoutTime;
    const peaksInChannel = allPivots.filter(p => p.type === 'P' && p.time >= t1.time && p.time < channelEndTime);
    if (peaksInChannel.length > 0) {
        const highestPeakInChannel = peaksInChannel.reduce((max, p) => p.price > max.price ? p : max);
        shapes.push({ name: 'analysis_connecting_line_up', type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(t1.time), y0: t1.price, x1: createDate(highestPeakInChannel.time), y1: highestPeakInChannel.price });
    }
    return { shapes, annotations };
}

function analyzeDownwardChannel(closestPivots, allPivots, klinesData, toleranceFactors) {
    const shapes = [], annotations = [];
    const peaks = closestPivots.filter(p => p.type === 'P').sort((a, b) => a.time - b.time);
    if (peaks.length < 2) return { shapes, annotations };
    const p1 = peaks[0], p2 = peaks[1];
    if (p2.price > p1.price) {
        annotations.push({ name: 'analysis_label_downtrend_end_pre', x: createDate(p2.time), y: p2.price, text: '<b>ÌïòÎùΩ Ï∂îÏÑ∏ Ï¢ÖÎ£å (P > P-1)</b>', showarrow: true, arrowhead: 7, ax: 0, ay: -40, bgcolor: 'darkgreen', bordercolor: 'white', borderwidth: 1, font: { color: 'white', size: 12 } });
        return { shapes, annotations };
    }
    const slope = (p2.price - p1.price) / (p2.time - p1.time);
    if (p2.time === p1.time) return { shapes, annotations };
    const xRange = chartContainer._fullLayout.xaxis.range, xStartTimestamp = new Date(xRange[0]).getTime(), xEndTimestamp = new Date(xRange[1]).getTime() + (24 * 60 * 60 * 1000);
    shapes.push({ name: 'analysis_trendline_down', type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(xStartTimestamp), y0: slope * (xStartTimestamp - p1.time) + p1.price, x1: createDate(xEndTimestamp), y1: slope * (xEndTimestamp - p1.time) + p1.price, line: { color: 'magenta', width: 1.5, dash: 'dot' } });
    const firstT = closestPivots.filter(p => p.type === 'T').sort((a, b) => a.time - b.time)[0];
    const breakthroughT = allPivots.filter(p => p.type === 'T' && p.time > firstT?.time && p.price < firstT?.price).sort((a, b) => a.time - b.time)[0];
    if (!breakthroughT) return { shapes, annotations };
    annotations.push({ name: `analysis_label_t_plus`, x: createDate(breakthroughT.time), y: breakthroughT.price, text: 'T+', showarrow: true, arrowhead: 4, ax: 0, ay: 35, bgcolor: 'rgba(20, 255, 147, 0.9)', font: { color: 'white', size: 14 } });
    shapes.push({ name: 'analysis_parallel_line_down', type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(xStartTimestamp), y0: slope * (xStartTimestamp - breakthroughT.time) + breakthroughT.price, x1: createDate(xEndTimestamp), y1: slope * (xEndTimestamp - breakthroughT.time) + breakthroughT.price, line: { color: 'magenta', width: 1.5, dash: 'dot' } });
    let upperBreakoutCandle = null, lowerBreakoutCandle = null;
    const startIndex = klinesData.findIndex(k => k[0] > p2.time);
    if (startIndex !== -1) {
        for (let i = startIndex; i < klinesData.length; i++) {
            const candle = klinesData[i], candleTime = candle[0], candleHigh = candle[2], candleLow = candle[3];
            if (!upperBreakoutCandle) {
                const upperBoundary = slope * (candleTime - p1.time) + p1.price;
                if (candleHigh > (upperBoundary * toleranceFactors.upper)) upperBreakoutCandle = candle;
            }
            if (!lowerBreakoutCandle && candleTime > breakthroughT.time) {
                const lowerBoundary = slope * (candleTime - breakthroughT.time) + breakthroughT.price;
                if (candleLow < (lowerBoundary * toleranceFactors.lower)) lowerBreakoutCandle = candle;
            }
            if (upperBreakoutCandle && (lowerBreakoutCandle || candleTime <= breakthroughT.time)) break;
            if (upperBreakoutCandle && lowerBreakoutCandle) break;
        }
    }
    if (upperBreakoutCandle) annotations.push({ name: 'analysis_label_break_up_downchannel', x: createDate(upperBreakoutCandle[0]), y: upperBreakoutCandle[2], text: '<b>ÏÉÅÎã® ÎèåÌåå</b>', showarrow: true, arrowhead: 7, ax: 0, ay: -40, bgcolor: 'rgba(0, 150, 255, 0.8)', bordercolor: 'white', borderwidth: 1, font: { color: 'white', size: 12 } });
    if (lowerBreakoutCandle) annotations.push({ name: 'analysis_label_break_down_downchannel', x: createDate(lowerBreakoutCandle[0]), y: lowerBreakoutCandle[3], text: '<b>ÌïòÎã® Ïù¥ÌÉà</b>', showarrow: true, arrowhead: 7, ax: 0, ay: 40, bgcolor: 'rgba(255, 140, 0, 0.8)', bordercolor: 'white', borderwidth: 1, font: { color: 'white', size: 12 } });
    const firstBreakoutTime = [upperBreakoutCandle, lowerBreakoutCandle].filter(Boolean).reduce((min, c) => Math.min(min, c[0]), Infinity);
    const channelEndTime = (firstBreakoutTime === Infinity) ? klinesData[klinesData.length - 1][0] : firstBreakoutTime;
    const troughsInChannel = allPivots.filter(p => p.type === 'T' && p.time >= p1.time && p.time < channelEndTime);
    if (troughsInChannel.length > 0) {
        const lowestTroughInChannel = troughsInChannel.reduce((min, p) => p.price < min.price ? p : min);
        shapes.push({ name: 'analysis_connecting_line_down', type: 'line', layer: 'below', xref: 'x', yref: 'y', x0: createDate(p1.time), y0: p1.price, x1: createDate(lowestTroughInChannel.time), y1: lowestTroughInChannel.price });
    }
    return { shapes, annotations };
}

function performAutoLabeling() {
    if (!chartInitialized) return;
    const lookaround = parseInt(document.getElementById('lookaround-input').value, 10);
    if (isNaN(lookaround) || lookaround < 1) return;
    const { allPivots } = findPivots(0, klinesData, lookaround);
    const newAutoAnnotations = allPivots.map((pivot, i) => ({
        name: `auto_${pivot.type}_${i}`, x: createDate(pivot.time), y: pivot.price,
        text: pivot.type, showarrow: true, arrowhead: 4, ax: 0, ay: pivot.type === 'P' ? -20 : 20,
        font: { size: 10, color: pivot.type === 'P' ? 'orange' : 'skyblue' }, bgcolor: 'rgba(0,0,0,0.6)'
    }));
    const manualAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => !a.name?.startsWith('auto_') && !a.name?.startsWith('analysis_'));
    const analysisAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => a.name?.startsWith('analysis_'));
    Plotly.relayout(chartContainer, { annotations: [...manualAnnotations, ...analysisAnnotations, ...newAutoAnnotations] });
}

// ===================================================================================
// ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© (Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨)
// ===================================================================================
function handleDrawingToolToggle(toolNameToToggle) {
    const turningOff = toolNameToToggle === 'box' && isBoxDrawingEnabled;
    isBoxDrawingEnabled = (toolNameToToggle === 'box' && !isBoxDrawingEnabled);
    const buttonText = isFullAnalysisDone ? 'üíé ÏãúÎ¶¨Ï¶à ÏÑ†ÌÉù' : 'üì¶ Box On';
    toggleBoxDrawingButton.textContent = isBoxDrawingEnabled ? '‚úã ÏÑ†ÌÉù Ìï¥Ï†ú' : buttonText;
    if (isBoxDrawingEnabled) { toggleBoxDrawingButton.classList.add('active'); }
    else { toggleBoxDrawingButton.classList.remove('active'); }
    currentBoxFirstPoint = null;
    if (turningOff && selectionBox) {
        drawnBoxes = drawnBoxes.filter(box => box.id !== selectionBox.id);
        selectionBox = null; selectedSeries = [];
        Plotly.relayout(chartContainer, { shapes: getCurrentlyVisibleShapes() });
        console.log("ÏÑ†ÌÉùÏù¥ Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.");
    }
}

function handleChartClick(event) {
    if (!chartInitialized || contextMenu.style.display === 'block' || event.target.closest('.select-outline')) return;
    const clickData = getClickCoordinates(event);
    if (!clickData) return;

    if (isBoxDrawingEnabled && event.button === 0) {
        if (!currentBoxFirstPoint) { currentBoxFirstPoint = clickData; }
        else {
            if (selectionBox) {
                drawnBoxes = drawnBoxes.filter(b => b.id !== selectionBox.id);
                selectionBox = null; selectedSeries = [];
            }
            const boxId = isFullAnalysisDone ? 'series_selection_box_' + Date.now() : BOX_SHAPE_NAME_PREFIX + Date.now();
            const newBoxShape = {
                id: boxId, type: 'rect', layer: 'below', editable: true, xref: 'x', yref: 'y',
                x0: createDate(Math.min(currentBoxFirstPoint.time.getTime(), clickData.time.getTime())),
                y0: Math.min(currentBoxFirstPoint.price, clickData.price),
                x1: createDate(Math.max(currentBoxFirstPoint.time.getTime(), clickData.time.getTime())),
                y1: Math.max(currentBoxFirstPoint.price, clickData.price),
                fillcolor: 'rgba(0, 123, 255, 0.2)',
                line: { color: 'rgba(0, 123, 255, 0.7)', width: 1 },
            };

            if (isFullAnalysisDone) {
                newBoxShape.fillcolor = 'rgba(255, 0, 0, 0.1)';
                newBoxShape.line = { color: 'rgba(255, 0, 0, 0.7)', width: 1.5, dash: 'dash' };
                selectionBox = newBoxShape;

                // 'Ï†ÑÏ≤¥ Î∂ÑÏÑù'ÏúºÎ°ú ÏÉùÏÑ±Îêú Î™®Îì† ÏãúÎ¶¨Ï¶à(Î©îÏù∏/ÏÑúÎ∏å) shapeÏùÑ Í∞ÄÏ†∏Ïò®Îã§.
                const allAnalyzedShapes = (chartContainer.layout.shapes || []).filter(s => s.name?.startsWith('series_'));

                const selectionX0 = new Date(selectionBox.x0).getTime(), selectionX1 = new Date(selectionBox.x1).getTime();
                
                selectedSeries = allAnalyzedShapes.map(s => ({
                    type: s.name.includes('MAIN') ? (s.name.includes('UP') ? 'MAIN_UP' : 'MAIN_DOWN') : (new Date(s.y1) > new Date(s.y0) ? 'SUB_UP' : 'SUB_DOWN'),
                    shape: s
                })).filter(s_obj => {
                     const shapeX0 = new Date(s_obj.shape.x0).getTime(), shapeX1 = new Date(s_obj.shape.x1).getTime();
                     return Math.max(selectionX0, shapeX0) <= Math.min(selectionX1, shapeX1);
                });
                
                // ÏÑ†ÌÉùÎêú ÏãúÎ¶¨Ï¶àÎì§Ïóê ÎåÄÌï¥ Îã§Ïãú Î∂ÑÏÑù Î∞è ÌÖêÏÑúÌôî ÏàòÌñâ
                const lookaroundValue = parseInt(document.getElementById('lookaround-input').value, 10);
                const allPivots = consolidatePivots(findPivots(0, klinesData, lookaroundValue).allPivots);
                analyzeAndVectorizeAllSeries(selectedSeries, allPivots);

            } else {
                 drawnBoxes.push(newBoxShape);
            }
            
            currentBoxFirstPoint = null;
            Plotly.relayout(chartContainer, { shapes: getCurrentlyVisibleShapes() });
        }
    } else {
        event.preventDefault();
        event.stopImmediatePropagation();
        triggerAnalysis(clickData.time.getTime());
    }
}

function triggerAnalysisAtCenter() {
    if (!chartInitialized) return;
    const currentXRange = chartContainer._fullLayout.xaxis.range;
    const centerX = new Date(currentXRange[0]).getTime() + (new Date(currentXRange[1]).getTime() - new Date(currentXRange[0]).getTime()) / 2;
    triggerAnalysis(centerX);
}

function isPointInShape(point, shape) {
    if (!point || !shape || shape.type !== 'rect') return false;
    const t = point.time.getTime(), p = point.price;
    const x0 = new Date(shape.x0).getTime(), x1 = new Date(shape.x1).getTime();
    return t >= Math.min(x0, x1) && t <= Math.max(x0, x1) && p >= Math.min(shape.y0, shape.y1) && p <= Math.max(shape.y0, shape.y1);
}

function handleContextMenu(event) {
    event.preventDefault();
    if (!chartInitialized) return;
    const clickData = getClickCoordinates(event);
    deleteBoxButton.style.display = 'none';
    contextMenuTargetInfo = null;
    if (clickData) {
        const clickedBox = drawnBoxes.find(box => isPointInShape(clickData, box));
        if (clickedBox && clickedBox.id !== selectionBox?.id) {
            deleteBoxButton.style.display = 'block';
            contextMenuTargetInfo = { type: 'box', id: clickedBox.id };
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
            document.addEventListener('click', () => contextMenu.style.display = 'none', { once: true });
        }
    }
}

function handleDeleteBox() {
    if (contextMenuTargetInfo?.type === 'box' && contextMenuTargetInfo.id) {
        drawnBoxes = drawnBoxes.filter(box => box.id !== contextMenuTargetInfo.id);
        Plotly.relayout(chartContainer, { shapes: getCurrentlyVisibleShapes() });
    }
    contextMenu.style.display = 'none';
}

function handleMouseMove(e) {
    if (!chartInitialized) return;
    const coords = getClickCoordinates(e);
    if (!coords) return handleMouseLeave();
    const analysisShapes = (chartContainer._fullLayout.shapes || []).filter(s => s.name?.startsWith('analysis_') || s.name?.startsWith('series_'));
    const analysisAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => a.name?.startsWith('analysis_'));
    const autoAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => a.name?.startsWith('auto_'));

    const crosshairShapes = [
        { name: "crosshair_v", type: "line", visible: true, line: CROSSHAIR_LINE_STYLE, yref: "paper", y0: 0, y1: 1, x0: coords.time, x1: coords.time },
        { name: "crosshair_h", type: "line", visible: true, line: CROSSHAIR_LINE_STYLE, xref: "paper", x0: 0, x1: 1, y0: coords.price, y1: coords.price }
    ];
    const crosshairAnnotations = [
        { x: 1.01, xref: "paper", y: coords.price, yref: "y", text: coords.price.toFixed(2), showarrow: false, font: { color: "black" }, bgcolor: "grey", borderpad: 2 },
        { x: coords.time, xref: "x", y: 0, yref: "paper", text: coords.time.toLocaleTimeString([], { hour12: false }), showarrow: false, font: { color: "black" }, bgcolor: "grey", borderpad: 2, yshift: -20 }
    ];
    Plotly.relayout(chartContainer, { shapes: [...crosshairShapes, ...analysisShapes, ...drawnBoxes], annotations: [...crosshairAnnotations, ...analysisAnnotations, ...autoAnnotations] });
}

function handleMouseLeave() {
    if (!chartInitialized) return;
    const analysisShapes = (chartContainer._fullLayout.shapes || []).filter(s => s.name?.startsWith('analysis_') || s.name?.startsWith('series_'));
    const analysisAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => a.name?.startsWith('analysis_'));
    const autoAnnotations = (chartContainer._fullLayout.annotations || []).filter(a => a.name?.startsWith('auto_'));
    Plotly.relayout(chartContainer, { shapes: [...getHiddenCrosshairShapes(), ...analysisShapes, ...drawnBoxes], annotations: [...analysisAnnotations, ...autoAnnotations] });
}

function handleKeyDown(event) {
    if (document.activeElement.tagName === 'INPUT') return;
    const key = event.key.toLowerCase();
    let preventDefault = true;
    if (key === 'c') triggerAnalysisAtCenter();
    else if (key === '+' || key === '=') zoomTime(true);
    else if (key === '-' || key === '_') zoomTime(false);
    else if (key === 'arrowup' || key === 'w') panPrice(0.05);
    else if (key === 'arrowdown' || key === 's') panPrice(-0.05);
    else if (key === 'arrowleft' || key === 'a') panTime(-PAN_FRACTION);
    else if (key === 'arrowright' || key === 'd') panTime(PAN_FRACTION);
    else preventDefault = false;
    if (preventDefault) event.preventDefault();
}

function handleWheelZoom(event) {
    if (!chartInitialized) return;
    event.preventDefault();
    zoomTime(event.deltaY < 0);
}

// ===================================================================================
// Ïú†Ìã∏Î¶¨Ìã∞ Î∞è Ìó¨Ìçº Ìï®Ïàò
// ===================================================================================
function getClickCoordinates(e) { const fullLayout = chartContainer._fullLayout; if (!fullLayout?.xaxis?._length) return null; const bRect = chartContainer.getBoundingClientRect(); const x = e.clientX - bRect.left - fullLayout.margin.l; const y = e.clientY - bRect.top - fullLayout.margin.t; if (x < 0 || x > fullLayout.xaxis._length || y < 0 || y > fullLayout.yaxis._length) return null; return { time: createDate(fullLayout.xaxis.p2d(x)), price: fullLayout.yaxis.p2d(y) }; }

function getCurrentlyVisibleShapes() {
    const analysisAndSeriesShapes = (chartContainer.layout.shapes || []).filter(s => s.name?.startsWith('analysis_') || s.name?.startsWith('series_'));
    const userBoxes = drawnBoxes.filter(b => b.id !== selectionBox?.id);
    const allShapes = [...userBoxes, ...analysisAndSeriesShapes];
    if (selectionBox) { allShapes.push(selectionBox); }
    return allShapes;
}

function zoomTime(zoomIn) { if (!chartInitialized) return; if (isXAutoRangeEnabled) { isXAutoRangeEnabled = false; xAutoRangeToggle.checked = false; } const range = chartContainer._fullLayout.xaxis.range.map(d => new Date(d).getTime()); const change = (range[1] - range[0]) * X_AXIS_ZOOM_FACTOR * (zoomIn ? 0.5 : -0.5); Plotly.relayout(chartContainer, { 'xaxis.range': [createDate(range[0] + change), createDate(range[1] - change)] }); }
function panTime(fraction) { if (!chartInitialized) return; if (isXAutoRangeEnabled) { isXAutoRangeEnabled = false; xAutoRangeToggle.checked = false; } const range = chartContainer._fullLayout.xaxis.range.map(d => new Date(d).getTime()); const move = (range[1] - range[0]) * fraction; Plotly.relayout(chartContainer, { 'xaxis.range': [createDate(range[0] + move), createDate(range[1] + move)] }).then(() => { if (fraction < 0 && !fetchingMoreData) { const viewportStartTime = new Date(chartContainer._fullLayout.xaxis.range[0]).getTime(); if (klinesData.length > 0 && (viewportStartTime - klinesData[0][0]) <= (candleIntervalMillis || 60000) * 50) fetchMoreHistoricalData(); } else if (fraction > 0 && !fetchingFutureData) { const viewportEndTime = new Date(chartContainer._fullLayout.xaxis.range[1]).getTime(); const lastKnownTime = klinesData.length > 0 ? klinesData[klinesData.length - 1][0] : 0; if (viewportEndTime >= lastKnownTime - (candleIntervalMillis || 60000) * 10) fetchFutureData(lastKnownTime + candleIntervalMillis, lastKnownTime + (CANDLES_TO_FETCH_ON_PAN_RIGHT * candleIntervalMillis)); } }); }
function adjustPriceScale(zoomIn) { if (!chartInitialized) return; if (isYAutoRangeEnabled) { isYAutoRangeEnabled = false; yAutoRangeToggle.checked = false; } const range = chartContainer._fullLayout.yaxis.range; const change = (range[1] - range[0]) * Y_AXIS_ZOOM_FACTOR * (zoomIn ? -0.5 : 0.5); Plotly.relayout(chartContainer, { 'yaxis.range': [range[0] - change, range[1] + change] }); }
function panPrice(fraction) { if (!chartInitialized) return; if (isYAutoRangeEnabled) { isYAutoRangeEnabled = false; yAutoRangeToggle.checked = false; } const range = chartContainer._fullLayout.yaxis.range; const move = (range[1] - range[0]) * fraction; Plotly.relayout(chartContainer, { 'yaxis.range': [range[0] + move, range[1] + move] }); }

function handleCalendarIconClick() { timeTravelPickerArea.style.display = timeTravelPickerArea.style.display === 'none' ? 'flex' : 'none'; if (timeTravelPickerArea.style.display === 'flex') datetimePicker.value = new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString().slice(0, 16); }
function handleLoadPastDataClick() { if (datetimePicker.value) fetchAndDisplayTimeTravelData(new Date(datetimePicker.value).getTime()); }
function handleXAutoRangeToggle() { isXAutoRangeEnabled = xAutoRangeToggle.checked; if (chartInitialized) { Plotly.relayout(chartContainer, { 'xaxis.autorange': isXAutoRangeEnabled }); if (!isXAutoRangeEnabled && klinesData.length > 0) updateChartRange(klinesData, true, false); } }
function handleYAutoRangeToggle() { isYAutoRangeEnabled = yAutoRangeToggle.checked; if (chartInitialized) { Plotly.relayout(chartContainer, { 'yaxis.autorange': isYAutoRangeEnabled }); if (!isYAutoRangeEnabled && klinesData.length > 0) updateChartRange(klinesData, false, true); } }
function handleRelayout(eventData) { if (eventData['xaxis.range[0]'] || eventData['xaxis.range']) { if (isXAutoRangeEnabled) { isXAutoRangeEnabled = false; xAutoRangeToggle.checked = false; } } if (eventData['yaxis.range[0]'] || eventData['yaxis.range']) { if (isYAutoRangeEnabled) { isYAutoRangeEnabled = false; yAutoRangeToggle.checked = false; } } if (Object.keys(eventData).some(k => k.startsWith('shapes['))) { drawnBoxes = (chartContainer.layout.shapes || []).filter(s => s.id?.startsWith(BOX_SHAPE_NAME_PREFIX)).map(s => ({ ...s, editable: true })); } }
function updateActiveTimeframeButton(activeTf) { timeframeButtonsContainer.querySelectorAll('button').forEach(b => b.classList.toggle('active', b.dataset.timeframe === activeTf)); }

// ===================================================================================
// DOMContentLoaded Ïù¥Î≤§Ìä∏
// ===================================================================================
timeframeButtonsContainer.addEventListener('click', (event) => {
    if (event.target.tagName === 'BUTTON' && event.target.dataset.timeframe) {
        const newTimeframe = event.target.dataset.timeframe;
        if (newTimeframe !== currentTimeframe) {
            currentTimeframe = newTimeframe;
            initializeCharts(currentSymbol, currentTimeframe);
        }
    }
});
document.addEventListener('DOMContentLoaded', () => {
    initializeCharts(currentSymbol, currentTimeframe);
});
    </script>
</body>
</html>